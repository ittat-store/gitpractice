From 1afc68a13bf5573624bf6ca597791e784f26d187 Mon Sep 17 00:00:00 2001
From: Suchand Ghosh <suchand.ghosh@borqs.com>
Date: Thu, 5 Jul 2018 16:20:43 +0530
Subject: [PATCH] M0066807: RJIL Data Collector implementation

1. Intializing diag socket for listning diag packet from qcril.
2. Enabling and disabling diag event from qcril based on qmi event.
3. Collating data in qcril and sending the same to gecko layer.
4. Modifying jason string for sending filtered data to matrics deamon.
5. Implement all counters.
6. Persist counters when device reboot, also across app/ril crash.
7. Reset counters in 24hrs or when date change which ever is earlier.
8. Comment out app based muting gaps calculation and send muting gaps
and jitter loss from 0x17F2.
9. Send bearer_id, mute events when actually mute.
10. Send Jitter loss VI5 as integer/number.

Change-Id: Iccc55cf2cdb1b2fec7ba75966b1d1ffc6abc310f
---
 b2g_telephony/NetworkDataCollector.cpp          | 735 ++++++++++++++++++++++-
 b2g_telephony/include/NetworkDataCollector.h    |  55 +-
 b2g_telephony/include/RIL.h                     |  47 +-
 qcril/common/data/qcril_data_netctrl.c          |   5 +
 qcril/data_collector/qcril_diag.c               | 747 ++++++++++++++++++++++++
 qcril/data_collector/qcril_diag.h               |  50 ++
 qcril/qcril_qmi/ims_socket/qcril_qmi_ims_misc.c |  24 +
 qcril/qcril_qmi/qcril.c                         |  18 +-
 qcril/qcril_qmi/qcril_qmi.mk                    |   2 +
 qcril/qcril_qmi/qcril_qmi_nas.c                 | 213 ++++++-
 qcril/qcril_qmi/qcril_qmi_voice.c               |  45 +-
 qcril/qcril_qmi/qcrili.h                        |  47 +-
 12 files changed, 1915 insertions(+), 73 deletions(-)
 create mode 100644 qcril/data_collector/qcril_diag.c
 create mode 100644 qcril/data_collector/qcril_diag.h

diff --git a/b2g_telephony/NetworkDataCollector.cpp b/b2g_telephony/NetworkDataCollector.cpp
index e2a60cb..bc85372 100755
--- a/b2g_telephony/NetworkDataCollector.cpp
+++ b/b2g_telephony/NetworkDataCollector.cpp
@@ -28,7 +28,7 @@
 #undef LOG_TAG
 #define LOG_TAG "NW_DATA_COLLECTOR"
 #include "LogUtils.h"
-#include <utils/SystemClock.h>
+#include <cutils/properties.h>
 #include <iostream>
 #include <fstream>
 #include <sys/un.h>
@@ -36,9 +36,6 @@
 #include <sstream>
 #include <iomanip>
 
-
-
-
 NS_NAMED_LITERAL_CSTRING(RILD_OEM_SOCKET_NAME, "qmux_radio/rild_oem");
 
 #define NETWORK_DATA_COLLECTOR_RETRY_SECONDS 60
@@ -70,8 +67,6 @@ NS_NAMED_LITERAL_CSTRING(DATA_COLLECTOR_SERVER_SOCKET_NAME, "/dev/socket/metrics
 #define DC_ACTIVE_BAND_E_UTRA_OPERATING_BAND_5 124
 #define DC_ACTIVE_BAND_E_UTRA_OPERATING_BAND_40 142
 
-
-
 typedef struct
 {
     uint8_t frameType;
@@ -184,7 +179,17 @@ NetworkDataCollector::~NetworkDataCollector() {
                  QLOGE("HandleUnSolicitedResponse, data collector event length = %d",event_size);
                  if(event_size) {
                      int eventType =  p[index+8];
-                     HandleDataCollectorEvent(eventType);
+                     QLOGD("HandleUnSolicitedResponse: received event = %d, is server ready = %d",eventType, mServerReady);
+                     time_t t = time(NULL);
+                     if(mServerReady && isDateChanged(t)) {
+                         char valueStr[16];
+                         sprintf(valueStr, "%ld", t);
+                         property_set(PROP_DATA_COLLECTOR_INIT_TIMESTAMP, valueStr);
+                         resetPersistValue(eventType);
+                     }
+                     if ((eventType != DATA_COLLECTOR_EVENT_INCOMING_CALL) && isClientAllowEventReporting(eventType)) {
+                         HandleDataCollectorEvent(eventType);
+                     }
                  }
             }
             if(event == LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND) {
@@ -209,10 +214,10 @@ NetworkDataCollector::~NetworkDataCollector() {
       }
  }
 
-void  NetworkDataCollector::SendCallTriggeredDataToServer() {
+ void  NetworkDataCollector::SendCallTriggeredDataToServer() {
     QLOGE("%s new thread began", __FUNCTION__);
     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_TRIGGERED);
-}
+ }
 
  void  NetworkDataCollector::SendCallAttemptFailedDataToServer() {
      QLOGE("%s new thread began", __FUNCTION__);
@@ -222,23 +227,98 @@ void  NetworkDataCollector::SendCallTriggeredDataToServer() {
  void  NetworkDataCollector::SendCallEstablishedDataToServer() {
     QLOGE("%s new thread began", __FUNCTION__);
     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ESTABLISHED);
-}
+ }
 
  void  NetworkDataCollector::SendCallDisconnectDataToServer() {
     QLOGE("%s new thread began", __FUNCTION__);
     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DISCONNECT);
-}
+ }
 
  void  NetworkDataCollector::SendCallDropDataToServer() {
     QLOGE("%s new thread began", __FUNCTION__);
     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DROP);
-}
+ }
+
+ void NetworkDataCollector::SendCallMutingDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_MUTING);
+ }
 
  void  NetworkDataCollector::SendTacUpdateDataToServer() {
     QLOGE("%s new thread began", __FUNCTION__);
     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_TAC_UPDATE);
-}
+ }
+
+ void  NetworkDataCollector::SendRsrpLessUpdateDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM);
+ }
+
+  void NetworkDataCollector::SendAttachFailureDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_ATTACH_FAILURE);
+ }
 
+ void NetworkDataCollector::SendOutOfServiceDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_OUT_OF_SERVICE);
+ }
+
+ void NetworkDataCollector::SendInServiceDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_IN_SERVICE);
+ }
+
+ void NetworkDataCollector::SendRrcConnectionReleaseDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE);
+ }
+
+ void NetworkDataCollector::SendRrcConnectionFailureDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE);
+ }
+
+ void NetworkDataCollector::SendRadioLinkFailureDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE);
+ }
+
+ void NetworkDataCollector::SendVolteRegDataToServer() {
+   QLOGE("%s new thread began", __FUNCTION__);
+   SendNetworkDataToServer(DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT);
+ }
+
+ void NetworkDataCollector::SendVoLTEConnLostDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST);
+ }
+
+ void NetworkDataCollector::SendIntraFrequencyHandOverDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER);
+ }
+
+ void NetworkDataCollector::SendInterFrequencyHandOverDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER);
+ }
+
+ void NetworkDataCollector::SendInterBandHandOverDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER);
+ }
+
+ void NetworkDataCollector::SendCellReselectionDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CELL_RESELECTION);
+ }
+
+
+ void  NetworkDataCollector::SendRachFailureUpdateDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_RACH_FAILURE);
+ }
 
  void NetworkDataCollector::HandleDataCollectorEvent( int eventType) {
     bool isValidType = true;
@@ -261,30 +341,64 @@ void  NetworkDataCollector::SendCallTriggeredDataToServer() {
             runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDropDataToServer);
             break;
         case DATA_COLLECTOR_EVENT_CALL_MUTING:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallMutingDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_SMS_SENT:
         case DATA_COLLECTOR_EVENT_SMS_RECIVED:
+            isValidType = false;
+            break;
         case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendVolteRegDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendVoLTEConnLostDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
+            isValidType = false;
+            break;
         case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendOutOfServiceDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_IN_SERVICE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendInServiceDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
-            isValidType = false;
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendAttachFailureDataToServer);
             break;
         case DATA_COLLECTOR_EVENT_TAC_UPDATE:
             runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendTacUpdateDataToServer);
             break;
         case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendRsrpLessUpdateDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendRrcConnectionReleaseDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendRrcConnectionFailureDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendRadioLinkFailureDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendIntraFrequencyHandOverDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendInterFrequencyHandOverDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendInterBandHandOverDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCellReselectionDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_RACH_FAILURE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendRachFailureUpdateDataToServer);
+            break;
         case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
         case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
+            isValidType = false;
+            break;
         default:
             isValidType = false;
             break;
@@ -476,6 +590,345 @@ const char* NetworkDataCollector::getDataCollectorEventCode(DataCollectorEventCo
     }
 }
 
+
+const char* NetworkDataCollector::getAttachFailStringFromAttachFailCode(uint32_t attach_fail_cause) {
+    switch(attach_fail_cause) {
+       case 0:   //Unspecified failure
+           return "Unspecified failure";
+       case 2:   //IMSI unknown in HSS
+           return "IMSI unknown";
+       case 3:   //Illegal UE
+           return "Illegal UE";
+       case 6:   //Illegal ME
+           return "Illegal ME";
+       case 9:   //UE identity cannot be derived by the network
+           return "UE identity Error";
+       case 10:  //Implicitly detached
+           return "Implicitly detached";
+       case 5:   //IMEI not accepted
+           return "IMEI not accepted";
+       case 7:   //EPS services not allowed
+           return "EPS services not allowed";
+       case 8:   //EPS services and non-EPS services not allowed
+           return "EPS services and non-EPS services not allowed";
+       case 11:  //PLMN not allowed
+           return "PLMN not allowed";
+       case 12:  //Tracking area not allowed
+           return "Tracking area not allowed";
+       case 13:  //Roaming not allowed in this tracking area
+           return "Roaming not allowed in this tracking area";
+       case 14:  //EPS services not allowed in this PLMN
+           return "EPS services not allowed in this PLMN";
+       case 15:  //No suitable cells in tracking area
+           return "No suitable cells in tracking area";
+       case 16:  //MSC temporarily not reachable
+           return "MSC temporarily not reachable";
+       case 17:  //Network failure
+           return "Network failure";
+       case 18:  //CS domain not available
+           return "CS domain not available";
+       case 19:  //ESM failure
+           return "ESM failure";
+       case 20:  //MAC failure
+           return "MAC failure";
+       case 21:  //Synch failure
+           return "Synch failure";
+       case 22:  //Congestion
+           return "Congestion";
+       case 23:  //UE security capabilities mismatch
+           return "UE security capabilities mismatch";
+       case 24:  //Security mode rejected, unspecified
+           return "Security mode rejected, unspecified";
+       case 25:  //Not authorized for this CSG
+           return "Not authorized for this CSG";
+       case 26:  //Non-EPS authentication unacceptable
+           return "Non-EPS authentication unacceptable";
+       case 35:  //Requested service option not authorized
+           return "Requested service option not authorized";
+       case 39:  //CS service temporarily not available
+           return "CS service temporarily not available";
+       case 40:  //No EPS bearer context activated
+           return "No EPS bearer context activated";
+       case 42:  //Sever Network Failure
+           return "Sever Network Failure";
+       case 95:  //Semantically incorrect message
+           return "Semantically incorrect message";
+       case 96:  //Invalid mandatory information
+           return "Invalid mandatory information";
+       case 97:  //Message type non-existent or not implemented
+           return "Message type non-existent or not implemented";
+       case 98:  //Message type not compatible with protocol state
+           return "Message type not compatible with protocol state";
+       case 99:  //Information element non-existent or not implemented
+           return "Information element non-existent or not implemented";
+       case 100: //Conditional IE error
+           return "Conditional IE error";
+       case 101: //Message not compatible with protocol state
+           return "Message not compatible with protocol state";
+       case 111: //Protocol error, unspecified
+           return "Protocol error unspecified";
+       case 999: //Not use, nw never send this code
+           return "None";
+
+       default:
+        QLOGD("getAttachFailStringFromAttachFailCode : unknown attach fail code %d", attach_fail_cause);
+            return "Error unspecified"; //Error unspecified, this is not expected.
+
+    }
+}
+
+const char* NetworkDataCollector::getRrcEstStringFromRrcConnCode(uint32_t rrc_conn_cause) {
+    switch(rrc_conn_cause) {
+       case 0:
+           return "emergency";
+       case 1:
+           return "highPriorityAccess";
+       case 2:
+           return "mt_Access";
+       case 3:
+           return "mo_Signalling";
+       case 4:
+           return "mo_Data";
+       case 5:
+           return "mo_Csfb";
+       case 65535:
+           return "NONE";
+       default:
+        QLOGD("getRrcEstStringFromRrcConnCode : unknown rrc conn code %d", rrc_conn_cause);
+            return "NONE"; //Error unspecified, this is not expected.
+
+    }
+}
+
+const char* NetworkDataCollector::getRrcRelStringFromRrcRelCode(uint32_t rrc_rel_cause) {
+    switch(rrc_rel_cause) {
+       case 1:
+           return "Other";
+       case 2:
+           return "cs-FallbackHighPriority";
+       case 3:
+           return "loadBalancingTAUrequired";
+       case 65535:
+           return "NONE";
+       default:
+        QLOGD("getRrcRelStringFromRrcRelCode : unknown rrc_rel_cause %d", rrc_rel_cause);
+            return "NONE"; //Error unspecified, this is not expected.
+
+    }
+}
+
+bool NetworkDataCollector::requireToSendData(DataCollectorEventCodes event, DataCollectorDataCodes data) {
+    switch(data) {
+        case DATA_CODE_RI8:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+                case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+                case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+                case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+                case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+                case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+                    return true;
+                default:
+                    return false;
+            }
+        case DATA_CODE_RI9:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
+                    return true;
+                default:
+                    return false;
+            }
+        case DATA_CODE_RI10:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+                case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+                case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+                case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+                case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+                case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+                case DATA_COLLECTOR_EVENT_RACH_FAILURE:
+                    return true;
+                default:
+                    return false;
+        }
+        case DATA_CODE_RI14:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
+                case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+                case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+                case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+                case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+                    return true;
+                default:
+                    return false;
+        }
+        case DATA_CODE_NI1:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+                    return true;
+                default:
+                    return false;
+        }
+        case DATA_CODE_NI2:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+                    return true;
+                default:
+                    return false;
+        }
+        case DATA_CODE_NI3:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_IN_SERVICE:
+                    return true;
+                default:
+                    return false;
+        }
+        case DATA_CODE_OI1:
+        case DATA_CODE_VI1:
+        case DATA_CODE_VI2:
+        case DATA_CODE_VI3:
+            switch(event) {
+                case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+                case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+                case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
+                case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
+                case DATA_COLLECTOR_EVENT_CALL_DROP:
+                case DATA_COLLECTOR_EVENT_CALL_MUTING:
+                    return true;
+                default:
+                    return false;
+        }
+        default:
+            QLOGD("requireToSendData : The data %d need to send always with all events", data);
+            return true;
+    }
+}
+
+bool NetworkDataCollector::isDateChanged(time_t currentTime) {
+    char storedTimeStamp[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_INIT_TIMESTAMP,storedTimeStamp,"");
+    std::time_t StoredTime = atol(storedTimeStamp);
+    struct tm *Storedtm = localtime(&StoredTime);
+    bool ret = false;
+    int storedDD = Storedtm->tm_mday;
+    int storedMM = Storedtm->tm_mon;
+    int storedYYYY = Storedtm->tm_year;
+    struct tm *currenttm = localtime(&currentTime);
+
+    if((currenttm->tm_mday != storedDD) || (currenttm->tm_mon != storedMM)
+            || (currenttm->tm_year != storedYYYY)) {
+        QLOGD("NetworkDataCollector: Date changed previous date: %02d-%02d-%d", storedDD, (1+storedMM), (1900+storedYYYY));
+        QLOGD("NetworkDataCollector: Date changed current time:  %s", asctime(currenttm));
+        ret = true;
+    }
+    return ret;
+}
+
+bool NetworkDataCollector::isClientAllowEventReporting(int event) {
+    char dcEventMask[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_EVENT_MASK,dcEventMask,"4294967295");
+    int dcEventMaskValueInt = atoi(dcEventMask);
+    bool ret = (dcEventMaskValueInt & (1 << (event-1))) != 0;
+    QLOGD("NetworkDataCollector: isClientFilterOutEventReporting of event = %d is %d (Filter: %d)", event,ret,dcEventMaskValueInt);
+    return ret;
+}
+
+void NetworkDataCollector::resetPersistValue(int event) {
+    char valueStr[16];
+    int resetCount;
+    QLOGD("NetworkDataCollector: resetPersistValue event = %d",event);
+    switch(event) {
+        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+            resetCount = 1;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MO_CALL, valueStr);
+            resetCount = 0;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MT_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_CALL_DROP, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DETACH, valueStr);
+        break;
+        case DATA_COLLECTOR_EVENT_INCOMING_CALL:
+            resetCount = 1;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MT_CALL, valueStr);
+            resetCount = 0;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MO_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_CALL_DROP, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DETACH, valueStr);
+        break;
+        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+            resetCount = 1;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL, valueStr);
+            resetCount = 0;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MO_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_MT_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_CALL_DROP, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DETACH, valueStr);
+        break;
+        case DATA_COLLECTOR_EVENT_CALL_DROP:
+            resetCount = 1;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_CALL_DROP, valueStr);
+            resetCount = 0;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MO_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_MT_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DETACH, valueStr);
+        break;
+        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+            resetCount = 1;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL, valueStr);
+            resetCount = 0;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MO_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_MT_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_CALL_DROP, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DETACH, valueStr);
+        break;
+        default:
+            resetCount = 0;
+            sprintf(valueStr, "%d", resetCount);
+            property_set(PROP_DATA_COLLECTOR_NUM_MO_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_MT_CALL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_CALL_DROP, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL, valueStr);
+            property_set(PROP_DATA_COLLECTOR_NUM_DETACH, valueStr);
+        break;
+    }
+}
+
 void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event) {
     uint8_t frame[MAX_RESPONSE_BYTES];
     bzero(frame,MAX_RESPONSE_BYTES);
@@ -487,8 +940,9 @@ void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *
 
     std::time_t currentTime = std::time(NULL);
 
-    char jsonPayload[MAX_RESPONSE_BYTES];
-    bzero(jsonPayload,MAX_RESPONSE_BYTES);
+    char jsonPayload[MAX_RESPONSE_BYTES*3/4];
+    bzero(jsonPayload,MAX_RESPONSE_BYTES*3/4);
+    char tmpJsonPayload[MAX_RESPONSE_BYTES/4];
 
     /*As per network_access_service_v01.h, RJIL LTE band mappings are as mentioned below. (nas_active_band_enum_v01).
      NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_3_V01 = 122,
@@ -505,15 +959,221 @@ void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *
         activeband = 0;
     }
 
-    // Note:- as per 80-nv304-6_b_qmi_network_access_service_spec , RSRP range: -44 to -140, RSRQ range : -3 to -20, LTE SNR level scaled integer in units of 0.1dB e.g. 24.6 has a value of 246.
-    sprintf (jsonPayload,"[{ \"seq_number\": %llu, \"timestamp\": %ld, \"payload\": { \"Name\":\"%s\",\"RI1\":%d,\"RI2\":%d,\"RI3\":%d,\"RI6\":%d,\"RI7\":%d,\"RI8\":%s,\"RI13\": %d,\"VI2\": %d,\"NI1\":%s,\"VI1\": \"%s\"}}]",
-                            mSeqNumber,currentTime,getDataCollectorEventCode(event),(140+pNetworkParams->rsrp),(20+pNetworkParams->rsrq),pNetworkParams->sinr/10, activeband, pNetworkParams->lte_earfcn,
-                            pNetworkParams->srv_status?"true":"false",pNetworkParams->timing_advance>0?pNetworkParams->timing_advance:0,mRilLastFailCause,pNetworkParams->Roaming_Indicator?"true":"false",(pNetworkParams->sip_reg_status==1)?"REGISTERED":"NOT REGISTER");
+    char NC1[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_MO_CALL,NC1,"");
+    char NC2[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_MT_CALL,NC2,"");
+    char NC3[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL,NC3,"");
+    char NC4[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_CALL_DROP,NC4,"");
+    char NC5[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_DATA_SESSION,NC5,"");
+    char NC6[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED,NC6,"");
+    char NC7[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_ATTACH,NC7,"");
+    char NC8[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL,NC8,"");
+    char NC9[PROPERTY_VALUE_MAX];
+    property_get(PROP_DATA_COLLECTOR_NUM_DETACH,NC9,"");
+
+
+    sprintf (jsonPayload,"[{ \"seq_number\": %llu, \"timestamp\": %ld, \"payload\": { \n\"Name\":\"%s\",\n\"LI4\": %d,\n\"RI1\":%d,\n\"RI2\":%d,\n\"RI3\":%d,\n\"RI4\": %d,\n\"RI5\": %d,\n\"RI6\":%d,\n\"RI7\":%d,\n\"RI11\": %d,\n\"RI12\": %d,\n\"RI13\": %d,\n\"NI4\": \"{ %d, %s, %d, %d, %d, %d , %d }\",\n\"NC1\": %d,\n\"NC2\": %d,\n\"NC3\": %d,\n\"NC4\": %d,\n\"NC5\": %d,\n\"NC6\": %d,\n\"NC7\": %d,\n\"NC8\": %d,\n\"NC9\": %d,\n\"VI4\": %d",
+            mSeqNumber,
+            currentTime,
+            getDataCollectorEventCode(event), //Name
+            pNetworkParams->pci, /*LI4*/
+            (140+pNetworkParams->rsrp), //RI1
+            (20+pNetworkParams->rsrq), //RI2
+            pNetworkParams->sinr/10, //RI3
+            pNetworkParams->cqi, //RI4
+            pNetworkParams->rankIndicator, //RI5
+            activeband, //RI6
+            pNetworkParams->lte_earfcn, /*RI7 */
+            pNetworkParams->prach_tx_power, //RI11
+            pNetworkParams->bler, //RI12
+            pNetworkParams->timing_advance>0?pNetworkParams->timing_advance:0, /*RI13 */
+            pNetworkParams->bearer_id,
+            (pNetworkParams->bearer_type == 1)?"dedicated":"default", //NI4 - start
+            pNetworkParams->qci,
+            pNetworkParams->ambr_ul,
+            pNetworkParams->ambr_dl,
+            pNetworkParams->gbr_ul,
+            pNetworkParams->gbr_dl, /* NI4-end*/
+            atoi(NC1), //NC1
+            atoi(NC2), //NC2 */
+            atoi(NC3), /*NC3*/
+            atoi(NC4), //NC4
+            atoi(NC5), //NC5 */
+            atoi(NC6), /*NC6*/
+            atoi(NC7), //NC7
+            atoi(NC8), //NC8 */
+            atoi(NC9), /*NC9*/
+            ((pNetworkParams->rtp_packet_loss < 0) || (pNetworkParams->rtp_packet_loss > 100))?0:pNetworkParams->rtp_packet_loss/*VI4*/);
+
+    //Disable this log because log marker assume this is duplicate events
+    //QLOGD("Common data for all: jsonPayload = %s",jsonPayload);
+
+    bzero(tmpJsonPayload,MAX_RESPONSE_BYTES/4);
+
+    switch(event) {
+        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
+        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
+        case DATA_COLLECTOR_EVENT_CALL_DROP:
+            sprintf (tmpJsonPayload, ",\n\"OI1\": [ %d, %d, %d ],\n\"VI1\": \"%s\",\n\"VI2\": %d",
+                pNetworkParams->rstd0, //OI1 - start
+                pNetworkParams->rstd1,
+                pNetworkParams->rstd2,// OI1 - end
+                (pNetworkParams->sip_reg_status==1)?"REGISTERED":"NOT REGISTER", //VI1
+                mRilLastFailCause /*VI2*/
+               );
+         break;
 
-   QLOGD(" payload = %s",jsonPayload);
+        case DATA_COLLECTOR_EVENT_CALL_MUTING:
+            sprintf (tmpJsonPayload, ",\n\"OI1\": [ %d, %d, %d ],\n\"VI1\": \"%s\",\n\"VI3\": \"{%d, %d, %d, %d}\",\n\"VI5\": %d,\n\"VI2\": %d",
+                pNetworkParams->rstd0, //OI1 - start
+                pNetworkParams->rstd1,
+                pNetworkParams->rstd2,// OI1 - end
+                (pNetworkParams->sip_reg_status==1)?"REGISTERED":"NOT REGISTER", //VI1
+                pNetworkParams->mute[0], //VI3 - start
+                pNetworkParams->mute[1],
+                pNetworkParams->mute[2],
+                pNetworkParams->mute[3],/* VI3-end*/
+                pNetworkParams->total_rtp_loss, //VI5
+                mRilLastFailCause /*VI2*/
+               );
+         break;
+
+        case DATA_COLLECTOR_EVENT_IN_SERVICE: //NE13
+            sprintf (tmpJsonPayload, ",\n\"NI3\": %d",
+                pNetworkParams->tac_fail_cause /*NI3*/);
+        break;
+
+        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE: //NE14
+            sprintf (tmpJsonPayload, ",\n\"RI10\": %d,\n\"NI1\":%s,\n\"NI2\": %d",
+                pNetworkParams->rrc_rel_cause, //RI10
+                pNetworkParams->Roaming_Indicator?"true":"false", //NI1
+                pNetworkParams->attach_fail_cause /*NI2*/);
+        break;
+
+        case DATA_COLLECTOR_EVENT_TAC_UPDATE: //NE15
+            sprintf (tmpJsonPayload, ",\n\"RI8\":%s,\n\"RI10\": %d,\n\"NI3\": %d",
+                pNetworkParams->srv_status?"true":"false", //RI8
+                pNetworkParams->rrc_rel_cause, //RI10
+                pNetworkParams->tac_fail_cause /*NI3*/);
+        break;
+
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE: //NE17
+            sprintf (tmpJsonPayload, ",\n\"RI9\":\"%s\"",
+                getRrcEstStringFromRrcConnCode(pNetworkParams->rrc_conn_cause) /*RI9*/);
+        break;
+
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE: //NE18
+            sprintf (tmpJsonPayload, ",\n\"RI8\":%s,\n\"RI10\": %d",
+                pNetworkParams->srv_status?"true":"false", //RI8
+                pNetworkParams->rrc_rel_cause/*RI10*/);
+        break;
+
+        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE: //NE19
+            sprintf (tmpJsonPayload, ",\n\"RI14\": %d",
+                pNetworkParams->tx_power/*RI14*/);
+            if (pNetworkParams->number_of_cells > 0) {
+                strcat(tmpJsonPayload,",\n\"RI15\": ["); //End sequence. Must append
+                int nocell = 0;
+                char tmpCellJsonPayload[MAX_RESPONSE_BYTES/16];
+                for (nocell = 0; nocell < pNetworkParams->number_of_cells; nocell++) {
+                    bzero(tmpCellJsonPayload,MAX_RESPONSE_BYTES/16);
+                    sprintf (tmpCellJsonPayload,"[ %d, %d, %d]",
+                        pNetworkParams->cells[nocell][0], //R115 - start of ith cell
+                        pNetworkParams->cells[nocell][1],
+                        pNetworkParams->cells[nocell][2] //R115 - End of ith cell
+                    );
+                    if (nocell < pNetworkParams->number_of_cells-1) {
+                        strcat(tmpCellJsonPayload,",");
+                    } else {
+                        strcat(tmpCellJsonPayload,"]");
+                    }
+                    strcat(tmpJsonPayload,tmpCellJsonPayload);
+                }
+            }
+        break;
+
+        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER: //NE20
+        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER: //NE21
+        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER: //NE22
+            sprintf (tmpJsonPayload, ",\n\"RI8\":%s,\n\"RI10\": %d,\n\"RI14\": %d",
+                pNetworkParams->srv_status?"true":"false", //RI8
+                pNetworkParams->rrc_rel_cause,/*RI10*/
+                pNetworkParams->tx_power/*RI14*/);
+            if (pNetworkParams->number_of_cells > 0) {
+                strcat(tmpJsonPayload,",\n\"RI15\": ["); //End sequence. Must append
+                int nocell = 0;
+                char tmpCellJsonPayload[MAX_RESPONSE_BYTES/16];
+                for (nocell = 0; nocell < pNetworkParams->number_of_cells; nocell++) {
+                    bzero(tmpCellJsonPayload,MAX_RESPONSE_BYTES/16);
+                    sprintf (tmpCellJsonPayload,"[ %d, %d, %d]",
+                        pNetworkParams->cells[nocell][0], //R115 - start of ith cell
+                        pNetworkParams->cells[nocell][1],
+                        pNetworkParams->cells[nocell][2] //R115 - end of ith cell
+                    );
+                    if (nocell < pNetworkParams->number_of_cells-1) {
+                        strcat(tmpCellJsonPayload,",");
+                    } else {
+                        strcat(tmpCellJsonPayload,"]");
+                    }
+                    strcat(tmpJsonPayload,tmpCellJsonPayload);
+                }
+            }
+        break;
+
+        case DATA_COLLECTOR_EVENT_CELL_RESELECTION: //NE23
+            sprintf (tmpJsonPayload, ",\n\"RI8\":%s,\n\"RI14\": %d",
+                pNetworkParams->srv_status?"true":"false", //RI8
+                pNetworkParams->tx_power/*RI14*/);
+            if (pNetworkParams->number_of_cells > 0) {
+                strcat(tmpJsonPayload,",\n\"RI15\": ["); //End sequence. Must append
+                int nocell = 0;
+                char tmpCellJsonPayload[MAX_RESPONSE_BYTES/16];
+                for (nocell = 0; nocell < pNetworkParams->number_of_cells; nocell++) {
+                    bzero(tmpCellJsonPayload,MAX_RESPONSE_BYTES/16);
+                    sprintf (tmpCellJsonPayload,"[ %d, %d, %d]",
+                        pNetworkParams->cells[nocell][0], //R115 - start of ith cell
+                        pNetworkParams->cells[nocell][1],
+                        pNetworkParams->cells[nocell][2] //R115 - End of ith cell
+                    );
+                    if (nocell < pNetworkParams->number_of_cells-1) {
+                        strcat(tmpCellJsonPayload,",");
+                    } else {
+                        strcat(tmpCellJsonPayload,"]");
+                    }
+                    strcat(tmpJsonPayload,tmpCellJsonPayload);
+                }
+            }
+        break;
+
+        case DATA_COLLECTOR_EVENT_RACH_FAILURE: //NE24
+            sprintf (tmpJsonPayload, ",\n\"RI10\": %d",
+                pNetworkParams->rrc_rel_cause/*RI10*/);
+        break;
+
+        default:
+            QLOGD("No extra specific data need to send with event %d.", event);
+         break;
+    }
+
+    QLOGD("Extra specific data for event %d: %s", event, tmpJsonPayload);
+
+    strcat(jsonPayload,tmpJsonPayload);
+
+    strcat(jsonPayload,"}}]"); //End sequence. Must append
+
+    QLOGD("Complete jsonPayload = %s",jsonPayload);
 
     mSeqNumber++;//increase it for next message
-    int length = strlen(jsonPayload);
+    uint32_t length = strlen(jsonPayload);
     QLOGD(" payload length = %d",length);
     uint32_t nwByteOrderlength = htonl(length);
     char numberStr[4];
@@ -525,19 +1185,24 @@ void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *
     frame[3]=numberStr[2];
     frame[4]=numberStr[3];
 
-    char stringhexdata[MAX_RESPONSE_BYTES/2];
+    for (int i=0;i<5;i++){
+        QLOGD(" frame byte %d = %d",i,frame[i]);
+    }
+
+    char stringhexdata[MAX_RESPONSE_BYTES*2];
     std::memcpy(stringhexdata, tohex(jsonPayload).c_str(), 2*length);
+
     uint8_t* body = HexStringToBytes(stringhexdata,length);
     std::memcpy(frame+5,body,length);
 
     if(mSocket && mSocket->mFd) {
         int n = write(mSocket->mFd,frame,5+length); // 1 for type, 4 for length - total 5 bytes
         if (n < 0) {
-            QRLOGE("ERROR writing to socket");
+            QLOGD("ERROR writing to socket");
         }
 
     } else {
-         QRLOGE("ERROR not connected to server socket");
+         QLOGD("ERROR not connected to server socket");
     }
 
     if(body != NULL)
@@ -564,13 +1229,14 @@ NS_IMETHODIMP NetworkDataCollector::sendHandShakeMsgToServer() {
     std::memcpy(stringhexdata, tohex(str1).c_str(), 2*length);
     uint8_t* body = HexStringToBytes(stringhexdata,length);
     std::memcpy(buffer+5,body,length);
+
     if(mSocket && mSocket->mFd) {
         int n = write(mSocket->mFd,buffer,5+length); // 1 for type, 4 for length -- total 5 bytes
         if (n < 0) {
-            QRLOGE("ERROR writing to socket");
+            QLOGD("ERROR writing to socket");
         }
     } else {
-        QRLOGE("ERROR no socket fd to server socket");
+        QLOGD("ERROR no socket fd to server socket");
     }
 
     if(body != NULL)
@@ -594,9 +1260,9 @@ NS_IMETHODIMP NetworkDataCollector::Run() {
     // server socket name
     socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
 
-    QLOGD(" NetworkDataCollector:run  begin");
+    QRLOGD(" NetworkDataCollector:run  begin");
     if (NS_IsMainThread()) {
-        QLOGE("Error: This will deadlock if called from the main thread");
+        QRLOGE("Error: This will deadlock if called from the main thread");
         return NS_ERROR_UNEXPECTED;
     }
 
@@ -610,7 +1276,7 @@ NS_IMETHODIMP NetworkDataCollector::Run() {
             sleep(NETWORK_DATA_COLLECTOR_RETRY_SECONDS);
 
              if(mShuttingDown) {
-                QLOGE(" NetworkDataCollector: server connection is not ready or shuting down, so return");
+                QRLOGE(" NetworkDataCollector: server connection is not ready or shuting down, so return");
                 return result;
              }
             // Connect to server socket
@@ -627,6 +1293,13 @@ NS_IMETHODIMP NetworkDataCollector::Run() {
                    // close socket so that we can create it again in loop
                     mSocket->OnDisconnect(mRil->mIsShuttingDown);
                 } else {
+                     time_t t = time(NULL);
+                     if(isDateChanged(t)) {
+                         char valueStr[16];
+                         sprintf(valueStr, "%ld", t);
+                         property_set(PROP_DATA_COLLECTOR_INIT_TIMESTAMP, valueStr);
+                         resetPersistValue(DATA_COLLECTOR_EVENT_CALL_MUTING);
+                     }
                  QRLOGD("Connect socket successful");
                     break;
                 }
@@ -691,7 +1364,7 @@ NS_IMETHODIMP NetworkDataCollector::Run() {
                   break;
              } else {
                   // handle the data collector server response.
-                 QLOGE("got response from server socket ret=%d",readResult);
+                 QLOGD("got response from server socket ret=%d",readResult);
                  mServerReady = true; // need to set on first handshake message response.
              }
         }
diff --git a/b2g_telephony/include/NetworkDataCollector.h b/b2g_telephony/include/NetworkDataCollector.h
index 3479953..6abac18 100755
--- a/b2g_telephony/include/NetworkDataCollector.h
+++ b/b2g_telephony/include/NetworkDataCollector.h
@@ -28,6 +28,7 @@
 #define NETWORK_DATA_COLLECTOR_H
 
 #include "RIL.h"
+#include <utils/SystemClock.h>
 
 class RIL;
 class RILResult;
@@ -35,9 +36,9 @@ class RilSocket;
 class OemRequest;
 class RilResponseHandler;
 
-
 typedef struct
 {
+    int32_t pci;
     int32_t rsrp;
     int32_t rsrq;
     int32_t sinr;
@@ -48,6 +49,34 @@ typedef struct
     int32_t Roaming_Indicator;
     int32_t sip_reg_status;
     int32_t tac;
+    int32_t cqi;
+    int32_t rankIndicator;
+    int32_t attach_fail_cause;
+    int32_t tac_fail_cause;
+    int32_t eps_bearer_id;
+    int32_t rrc_conn_cause;
+    int32_t rrc_rel_cause;
+    int32_t prach_tx_power;
+    int32_t bler;
+    int32_t tx_power;
+    int32_t rstd0;
+    int32_t rstd1;
+    int32_t rstd2;
+    int32_t rtp_packet_loss;
+    int32_t total_rtp_loss;
+    int32_t bearer_id;
+    int32_t bearer_type;
+    int32_t qci;
+    int32_t ambr_ul;
+    int32_t ambr_dl;
+    int32_t gbr_ul;
+    int32_t gbr_dl;
+    int32_t number_of_attach;
+    int32_t number_of_attach_fail;
+    int32_t number_of_detach;
+    int32_t cells[12][3]; //Twelve set of neighbor cells each cell contains {pci, rsrp, rsrq}
+    int32_t number_of_cells;
+    int32_t mute[4]; //Array of numbers for extra short, short, medium and long muting events Ex: {5,2,4,0}
 }qmi_ril_nw_data_collector_Params;
 
 class DataCollectorSocket {
@@ -90,6 +119,22 @@ public:
   void  SendCallDisconnectDataToServer();
   void  SendCallDropDataToServer();
   void  SendTacUpdateDataToServer();
+  void SendAttachFailureDataToServer();
+  void SendOutOfServiceDataToServer();
+  void SendInServiceDataToServer();
+  void SendRrcConnectionReleaseDataToServer();
+  void SendRrcConnectionFailureDataToServer();
+  void SendRadioLinkFailureDataToServer();
+  void SendVolteRegDataToServer();
+  void SendVoLTEConnLostDataToServer();
+  void SendIntraFrequencyHandOverDataToServer();
+  void SendInterFrequencyHandOverDataToServer();
+  void SendInterBandHandOverDataToServer();
+  void SendCellReselectionDataToServer();
+  void SendCallMutingDataToServer();
+  void SendRachFailureUpdateDataToServer();
+  void SendRsrpLessUpdateDataToServer();
+
   void HandleDataCollectorEvent( int eventType);
   void Shutdown();
   std::string tohex(const  std::string& s, bool upper=true);
@@ -102,6 +147,14 @@ private:
   nsresult WaitForResponse(uint32_t* aResult,  const uint8_t** aResponse, uint32_t* aRespLength);
   void sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event);
   const char* getDataCollectorEventCode(DataCollectorEventCodes eventType);
+  const char* getAttachFailStringFromAttachFailCode(uint32_t attach_fail_cause);
+  const char* getRrcEstStringFromRrcConnCode(uint32_t rrc_conn_cause);
+  const char* getRrcRelStringFromRrcRelCode(uint32_t rrc_rel_cause);
+  bool requireToSendData(DataCollectorEventCodes event, DataCollectorDataCodes data);
+  void resetPersistValue(int event);
+  bool isDateChanged(time_t currentTime);
+  bool isClientAllowEventReporting(int event);
+
   RIL* mRil;
   DataCollectorSocket* mSocket;
     // Used to simulate synchronous calls
diff --git a/b2g_telephony/include/RIL.h b/b2g_telephony/include/RIL.h
index b297ee7..30cb4b9 100755
--- a/b2g_telephony/include/RIL.h
+++ b/b2g_telephony/include/RIL.h
@@ -108,6 +108,18 @@ const char* RequestToString(int request);
 #define RIL_REQUEST_ALLOW_DATA RIL_REQUEST_SET_DATA_SUBSCRIPTION
 #endif
 
+#define PROP_DATA_COLLECTOR_NUM_DATA_SESSION "persist.radio.dc.datasession"
+#define PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED "persist.radio.dc.faildata"
+#define PROP_DATA_COLLECTOR_INIT_TIMESTAMP "persist.radio.dc.timestamp"
+#define PROP_DATA_COLLECTOR_NUM_ATTACH "persist.radio.dc.numofattach"
+#define PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL "persist.radio.dc.attachfail"
+#define PROP_DATA_COLLECTOR_NUM_DETACH "persist.radio.dc.numofdettach"
+#define PROP_DATA_COLLECTOR_NUM_MO_CALL "persist.radio.dc.nummocall"
+#define PROP_DATA_COLLECTOR_NUM_MT_CALL "persist.radio.dc.nummtcall"
+#define PROP_DATA_COLLECTOR_NUM_DIAL_FAIL "persist.radio.dc.numofdialfail"
+#define PROP_DATA_COLLECTOR_NUM_CALL_DROP "persist.radio.dc.numofcalldrop"
+#define PROP_DATA_COLLECTOR_EVENT_MASK "persist.radio.dc.eventmask"
+
 #define RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION
 
 #define CUSTOM_RIL_UNSOL_RESPONSE_BASE 2000
@@ -140,7 +152,7 @@ typedef enum {
 } SocketId;
 
 enum DataCollectorEventCodes {
-    DATA_COLLECTOR_EVENT_CALL_TRIGGERED,
+    DATA_COLLECTOR_EVENT_CALL_TRIGGERED = 1,
     DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED,
     DATA_COLLECTOR_EVENT_CALL_ESTABLISHED,
     DATA_COLLECTOR_EVENT_CALL_DISCONNECT,
@@ -165,7 +177,38 @@ enum DataCollectorEventCodes {
     DATA_COLLECTOR_EVENT_CELL_RESELECTION,
     DATA_COLLECTOR_EVENT_RACH_FAILURE,
     DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL,
-    DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL
+    DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL,
+    DATA_COLLECTOR_EVENT_INCOMING_CALL
+};
+
+enum DataCollectorDataCodes {
+    DATA_CODE_LI4 = 1, //PCI
+    DATA_CODE_RI1,    //RSRP
+    DATA_CODE_RI2,    //RSRQ
+    DATA_CODE_RI3,    //SINR
+    DATA_CODE_RI4,    //CQI
+    DATA_CODE_RI5,    //Rank Indicator
+    DATA_CODE_RI6,    //Band Indication
+    DATA_CODE_RI7,    //EARFCN
+    DATA_CODE_RI8,    //Service Indication
+    DATA_CODE_RI9,    //RRC Connection cause
+    DATA_CODE_RI10,    //RRC Release cause
+    DATA_CODE_RI11,    //RACH Max Power
+    DATA_CODE_RI12,    //BLER
+    DATA_CODE_RI13,    //TA
+    DATA_CODE_RI14,    //Tx Power
+    DATA_CODE_RI15,    //Neighbor cell info.
+    DATA_CODE_NI1,    //Roaming state
+    DATA_CODE_NI2,    //ATTACH fail causes
+    DATA_CODE_NI3,    //TAC update failures
+    DATA_CODE_NI4,    //EPS Details
+    DATA_CODE_OI1,    //OTDOA
+    DATA_CODE_VI1,    //SIP registration Status
+    DATA_CODE_VI2,    //SIP Session End (reason)
+    DATA_CODE_VI3,    //Mute related parameters
+    DATA_CODE_VI4,    //RTP Packet Loss
+    DATA_CODE_HI1,    //Rx bytes
+    DATA_CODE_HI2    //Tx bytes
 };
 
 typedef struct {
diff --git a/qcril/common/data/qcril_data_netctrl.c b/qcril/common/data/qcril_data_netctrl.c
index 075a4c6..51ea57d 100755
--- a/qcril/common/data/qcril_data_netctrl.c
+++ b/qcril/common/data/qcril_data_netctrl.c
@@ -121,6 +121,8 @@ when       who     what, where, why
 */
 #define QCRIL_DATA_PROPERTY_TIMEOUT             "persist.qcril.datacall_timeout"
 #define QCRIL_DATA_PROPERTY_TIMEOUT_SIZE        (6)
+#define PROP_DATA_COLLECTOR_NUM_DATA_SESSION "persist.radio.dc.datasession"
+#define PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED "persist.radio.dc.faildata"
 
 /*---------------------------------------------------------------------------
   System properties for power optimization:
@@ -8159,6 +8161,7 @@ void qcril_data_request_setup_data_call
 
   QCRIL_DATA_MUTEX_UNLOCK(&info_tbl_mutex);
   QCRIL_LOG_DEBUG("%s", "qcril_data_request_setup_data_call: EXIT with suc");
+  incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_DATA_SESSION);
 
   return;
 
@@ -8168,6 +8171,7 @@ err_label:
                                                instance_id,
                                                params_ptr->t,
                                                info_tbl[i].call_info.inactiveReason );
+  incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED);
 cleanup:
   /* clean up if we had reserved an info tbl entry */
   if (i < MAX_CONCURRENT_UMTS_DATA_CALLS    &&
@@ -8179,6 +8183,7 @@ cleanup:
 err_bad_input:
   QCRIL_DATA_MUTEX_UNLOCK(&info_tbl_mutex);
   QCRIL_LOG_ERROR("%s", "qcril_data_request_setup_data_call: EXIT with FAILURE");
+  incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_DATA_SESSION_FAILED);
   return;
 
 }/* qcril_data_request_setup_data_call() */
diff --git a/qcril/data_collector/qcril_diag.c b/qcril/data_collector/qcril_diag.c
new file mode 100644
index 0000000..225ce67
--- /dev/null
+++ b/qcril/data_collector/qcril_diag.c
@@ -0,0 +1,747 @@
+
+/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
+
+Application for Data Collector using Diag Consumer Interface
+
+GENERAL DESCRIPTION
+This is an application to collect modem parameters using Diag Consumer Interface APIs.
+
+*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
+
+/*===========================================================================*/
+
+#include "qcril_diag.h"
+
+/* Structure for Log packet parsing*/
+struct log_code_name_type {
+    int log_code;
+    char *name;
+};
+
+/* Channel proc set to MSM by default */
+static int channel = MSM;
+
+static int err, client_id;
+
+/* Set flag to print the bytes */
+static inline void print_bytes(unsigned char *buf, int len, int flag)
+{
+    int i = 0;
+    if (!flag)
+        return;
+    if (!buf || len <= 0)
+        return;
+    for (i = 0; i < len; i++) {
+        if(i % 8 == 0)
+        QCRIL_LOG_INFO("  %02x  ", buf[i]);
+    }
+    QCRIL_LOG_INFO("\n");
+}
+unsigned char *dci_rsp_pkt = NULL;
+
+#define CQI_MASK 0x3C
+#define CQI_SHIFT 2
+
+#define RRC_OTA_CONN_MASK 0x0E
+
+#define RRC_OTA_REL_MASK 0xF8
+#define RRC_OTA_REL_SHIFT 3
+
+#define PUCCH_REPORT_TYPE_MASK 0x3C
+#define PUCCH_REPORT_TYPE_SHIFT 1
+
+#define RI_MASK 0x80
+#define RI_SHIFT 7
+
+#define TX_POWER_MASK 0x7F
+
+#define RLF_TYPE_MASK 0xFFF
+
+static int rach_cause = -1;
+
+static int cqi =0 ;
+static int rankIndicator =0 ;
+static int temp_rankIndicator = 0 ;
+static int rrc_conn_cause =0 ;
+static int attach_reject_cause =0 ;
+static int rrc_rel_cause =0 ;
+static int prach_tx_power =0 ;
+static int gm_tx_power =0 ;
+static int frequeny= 0;
+static int total_rtp_loss= 0;
+static int tac_fail_cause = 0;
+static int bearer_id = 0;
+static int bearer_type = 0; //default
+static int qci = 0;
+static int ambr_ul = 0;
+static int ambr_dl = 0;
+static int gbr_ul = 0;
+static int gbr_dl = 0;
+static int bler = 0;
+static int crc_pass = 0;
+static int crc_fail = 0;
+static int local_counter = 0;
+static int sequence_number = 0;
+static int extra_short_mute = 0;
+static int short_mute = 0;
+static int medium_mute = 0;
+static int long_mute = 0;
+static int rtp_loss = 0;
+static int in_call = 0;
+static int total_rtp_pckt_cnt = 0;
+static int total_loss_rtp_pckt_cnt = 0;
+static int rtp_packet_loss = 0;
+static int rstd[3];
+static int number_of_attach = 0;
+static int number_of_attach_fail = 0;
+static int number_of_detach = 0;
+static uint8_t dataCollectorEvents = -1;
+#define TOTAL_EVENT_CODES    5
+#define TOTAL_LOG_CODES    9
+
+#define PROP_DATA_COLLECTOR_NUM_ATTACH "persist.radio.dc.numofattach"
+#define PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL "persist.radio.dc.attachfail"
+#define PROP_DATA_COLLECTOR_NUM_DETACH "persist.radio.dc.numofdettach"
+
+uint16 log_codes_array[TOTAL_LOG_CODES] = {45248,45415,/*5481,*/6130,45415,45282,45292,6192,6193,5529};
+
+uint16 log_codes_array_cqi[1] = {45389};
+uint16 log_codes_array_bler[1] = {45427};
+
+int event_codes_array[TOTAL_EVENT_CODES] = {
+    EVENT_LTE_RRC_RADIO_LINK_FAILURE,
+    EVENT_LTE_RRC_NEW_CELL_IND,
+    EVENT_LTE_RACH_ACCESS_START,
+    EVENT_LTE_RACH_ACCESS_RESULT,
+    EVENT_LTE_EMM_OTA_OUTGOING_MSG
+};
+
+qmi_ril_nw_data_collector_Param diag_ril_nw_data_collector_Params;
+
+void process_dci_log_stream(unsigned char *ptr, int len)
+{
+
+    QCRIL_LOG_INFO(" process_dci_log_stream: Received an event Id : %d   of size %d bytes \n" , *(uint16 *)(ptr + 2) , len);
+    print_bytes(ptr, len, FALSE);
+    switch (*(uint16 *)(ptr + 2)) {
+        case 45389:
+            QCRIL_LOG_INFO(" cqi 45389  diag_log_stream_config 0xB14D  LTE LL1 PUCCH CSF – periodic temp_rankIndicator %d\n", temp_rankIndicator);
+            int report_type = PUCCH_REPORT_TYPE_MASK & ptr[15] ;
+            report_type = report_type >> PUCCH_REPORT_TYPE_SHIFT;
+            QCRIL_LOG_INFO(" cqi 45389  diag_log_stream_config 0xB14D  LTE LL1 PUCCH CSF – periodic report_type %d\n", report_type);
+            if (report_type == 2){
+                int value = CQI_MASK & ptr[17];
+                value = value >> CQI_SHIFT;
+                if(value > 0) {
+                    cqi = value;
+                }
+                QCRIL_LOG_INFO("cqi value = %d " , cqi);
+            } else if (report_type == 4){
+                rankIndicator = RI_MASK & ptr[16];
+                rankIndicator = (rankIndicator >> RI_SHIFT ) +1; // 0 -> Rank 1
+                temp_rankIndicator = rankIndicator;
+                QCRIL_LOG_INFO("rankIndicator value = %d " , rankIndicator);
+            }
+            if( (temp_rankIndicator > 0 ) && (cqi > 0) ) {
+                QCRIL_LOG_INFO("45459 diag_log_stream_config disabling 0xB14D  LTE LL1 PUCCH CSF – periodic 0xB14E  LTE LL1 PUSCH CSF periodic cqi %d, rankIndicator %d\n", cqi,rankIndicator);
+                err = diag_log_stream_config(client_id, DISABLE, log_codes_array_cqi,1);
+                if (err != DIAG_DCI_NO_ERROR) {
+                    QCRIL_LOG_INFO(" Error sending diag_log_stream_config - SET_LOG_MASK to peripheral, err: %d, errno: %d\n", err, errno);
+                }
+            }
+            break;
+        case 45248:
+            QCRIL_LOG_INFO(" 45248  diag_log_stream_config 0xB0C0  LTE RRC OTA Packet \n");
+            int rrc_ota_type = ptr[24];
+            QCRIL_LOG_INFO("Packet version %d rrc_ota_type value = %d ", ptr[12], rrc_ota_type);
+            if(((ptr[12] == 13) && (rrc_ota_type == 7)) || ((ptr[12] == 12) && (rrc_ota_type == 14))) { // pduNum UL_CCCH = 14 if v12 or pduNum = 7 if v13
+                int value_rrc_conn_cause = RRC_OTA_CONN_MASK & ptr[36] ;
+                value_rrc_conn_cause = value_rrc_conn_cause >> 1 ;
+                QCRIL_LOG_INFO("value_rrc_conn_cause = %d " , value_rrc_conn_cause);
+                if(value_rrc_conn_cause >= 0) {
+                    rrc_conn_cause = value_rrc_conn_cause;
+                }
+            } else if(((ptr[12] == 13) && (rrc_ota_type == 6)) || ((ptr[12] == 12) && (rrc_ota_type == 13))) { // pduNum DL_CCCH = 13 if v12 or pduNum = 6 if v13
+                int value_rrc_rel = RRC_OTA_REL_MASK & ptr[31] ;
+                value_rrc_rel = value_rrc_rel >> RRC_OTA_REL_SHIFT;
+                if (value_rrc_rel == 5) {
+                    int value_rrc_rel_cause = 0xF0 & ptr[32];
+                    value_rrc_rel_cause = value_rrc_rel_cause >> 4;
+                    if(value_rrc_rel_cause >= 0) {
+                        rrc_rel_cause = value_rrc_rel_cause;
+                        QCRIL_LOG_INFO("rrc_rel_cause value = %d " , rrc_rel_cause);
+                        /* Valid rrc releaseCause per spec 36.331 (Release 14.6.2):
+                        0    loadBalancingTAUrequired
+                        1    Other
+                        2    Cs-FallbackHighPriority
+                        3    Rrc-Suspend-v1320
+                        */
+                        if(rrc_rel_cause < 4) {
+                            QCRIL_LOG_INFO("rrc_rel_cause DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE");
+                            dataCollectorEvents = DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE;
+                        } else {
+                            QCRIL_LOG_INFO("rrc_rel_cause DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE");
+                            dataCollectorEvents = DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE;
+
+                        }
+                        //send service state unsol from here.
+                        QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents);
+                        qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+                    }
+                }
+            }
+            break;
+        case 45415:
+            QCRIL_LOG_INFO(" cqi 45415  diag_log_stream_config 0xB167  LTE Random Access Request (MSG1) Report \n");
+            int value_p_tx_power = ptr[20] ;
+            if(value_p_tx_power > 0 && value_p_tx_power < 120) {
+                prach_tx_power = value_p_tx_power;
+            }
+            QCRIL_LOG_INFO("prach_tx_power value = %d and received p_tx_power = %d" , prach_tx_power, value_p_tx_power);
+            break;
+        /* case 5481:
+             QCRIL_LOG_INFO(" QCRIL_DIAG:   5481  diag_log_stream_config 0x1569 IMS RTP Packet Loss  \n");
+              rtp_loss =  ptr[13];
+                if(rtp_loss >=25 && rtp_loss <= 50) {
+                    extra_short_mute++;
+                } else if(rtp_loss > 50 && rtp_loss <= 150) {
+                    short_mute++;
+                } else if(rtp_loss > 150 && rtp_loss <= 250) {
+                    medium_mute++;
+                 } else if(rtp_loss > 250) {
+                    long_mute++;
+                }
+                if(rtp_loss >= 100) {
+                    dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_MUTING;
+                    QCRIL_LOG_INFO ("data collector indication - DATA_COLLECTOR_EVENT_CALL_MUTING rtp_loss %d",rtp_loss);
+                    qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents,      sizeof(dataCollectorEvents));
+                }
+            break; */
+        case 6130:
+             QCRIL_LOG_INFO(" QCRIL_DIAG:   6130  diag_log_stream_config 0x17F2 IMS Voice Call Statistics   \n");
+            total_rtp_pckt_cnt = (ptr[31] << 24) + (ptr[30] << 16) + (ptr[29] << 8) + ptr[28]; //*(uint32 *)(ptr + 16);
+            int value_total_rtp_loss = (ptr[35] << 24) + (ptr[34] << 16) + (ptr[33] << 8) + ptr[32]; //*(uint32 *)(ptr + 20);
+            extra_short_mute = ptr[134];
+            short_mute = ptr[135];
+            medium_mute = ptr[136];
+            long_mute = ptr[137];
+            total_rtp_loss = (ptr[71] << 8) + ptr[70];
+            rtp_packet_loss = 0;
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   6130  diag_log_stream_config 0x17F2  IMS Voice Call Statistics total rtp received %d rtp rx loss %d\n", total_rtp_pckt_cnt, value_total_rtp_loss);
+            if (value_total_rtp_loss > 0  && total_rtp_pckt_cnt > 0 && total_rtp_pckt_cnt > value_total_rtp_loss) {
+                rtp_packet_loss = 100*value_total_rtp_loss/(value_total_rtp_loss + total_rtp_pckt_cnt);
+                QCRIL_LOG_INFO(" QCRIL_DIAG:   6130  diag_log_stream_config 0x17F2  IMS Voice Call Statistics rtp_packet_loss %d \n", rtp_packet_loss);
+            }
+            QCRIL_LOG_INFO ("data collector indication 0x17F2 - DATA_COLLECTOR_EVENT_CALL_MUTING muting gaps %d %d %d %d, jitter loss %d", extra_short_mute,short_mute,medium_mute,long_mute,total_rtp_loss);
+            if (extra_short_mute > 0 || short_mute > 0 || medium_mute > 0 || long_mute > 0 || total_rtp_loss > 0) {
+                //Special case: where there are non-zero muting gaps but jitter loss is zero and RTP packet loss % is round off to zero.
+                //In that case, set RTP packet loss as 1% minimum value because in metrics_daemon it's int type.
+                if ((total_rtp_loss == 0) && (rtp_packet_loss < 1) && (value_total_rtp_loss > 0)) {
+                    rtp_packet_loss = 1;
+                }
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_MUTING;
+                qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents,      sizeof(dataCollectorEvents));
+            }
+            break;
+        case 45292:
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   45292  diag_log_stream_config 0xB0EC LTE NAS EMM Plain OTA Incoming Message msg_type %d \n", ptr[17]);
+            int msg_type = ptr[17];
+            if (msg_type == 75 || msg_type == 73) { //TAC rejected (75), TAC accept (73)
+                int value_tac_fail_cause = ptr[18];
+                tac_fail_cause = value_tac_fail_cause;
+                temp_rankIndicator = 0; //Let retrieve rank indicator again in 0xB14D
+                QCRIL_LOG_INFO(" QCRIL_DIAG:   45292  diag_log_stream_config 0xB0EC LTE NAS EMM Plain OTA Incoming Message   value_tac_fail_cause %d \n", value_tac_fail_cause);
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_TAC_UPDATE; //TAC accept, failed/rejected. Need update to metrics_daemon to know the TAC failure reason.
+                QCRIL_LOG_INFO(" QCRIL_DIAG:   45292 data collector indication - %d", dataCollectorEvents);
+                qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+            } else if (msg_type == 68) { //Attach failed
+                number_of_attach_fail++;
+                attach_reject_cause = ptr[18];
+                temp_rankIndicator = 0; //Let retrieve rank indicator again in 0xB14D
+                incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_ATTACH_FAIL);
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_ATTACH_FAILURE;
+                QCRIL_LOG_INFO(" QCRIL_DIAG:   45292 data collector indication - %d", dataCollectorEvents);
+                QCRIL_LOG_INFO(" QCRIL_DIAG:   45292 data collector number_of_attach_fail - %d attach_reject_cause %d", number_of_attach_fail,attach_reject_cause);
+                qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+            }
+            break;
+        case 45282:
+             QCRIL_LOG_INFO(" QCRIL_DIAG:   45282  diag_log_stream_config 0xB0E2  Activate dedicated EPS bearer context request Msg ");
+             int bearer_msg_type = ptr[18];
+            if (bearer_msg_type == 193) { //0xC1 Activate default EPS bearer
+                int eps_qos_length = ptr[19];
+                QCRIL_LOG_INFO("  eps_qos_length %d \n",eps_qos_length);
+                bearer_id = (ptr[16] >> 4);
+                bearer_type = 0; //default
+                if(eps_qos_length == 1) {
+                    qci = ptr[20];
+                    ambr_ul = 0;
+                    ambr_dl = 0;
+                    gbr_ul = 0;
+                    gbr_dl = 0;
+                } else {
+                    qci = ptr[20];
+                    ambr_ul = get_bit_Rate(ptr[21]);
+                    ambr_dl = get_bit_Rate(ptr[22]);
+                    gbr_ul = get_bit_Rate(ptr[23]);
+                    gbr_dl = get_bit_Rate(ptr[24]);
+                }
+            } else if (bearer_msg_type == 197) { //0xC5 Activate dedicated EPS bearer
+                int eps_qos_length = ptr[20];
+                QCRIL_LOG_INFO("  eps_qos_length %d \n",eps_qos_length);
+                bearer_id = (ptr[16] >> 4);
+                bearer_type = 1; //dedicated
+                if(eps_qos_length == 1) {
+                    qci = ptr[21];
+                    ambr_ul = 0;
+                    ambr_dl = 0;
+                    gbr_ul = 0;
+                    gbr_dl = 0;
+                } else {
+                    qci = ptr[21];
+                    ambr_ul = get_bit_Rate(ptr[22]);
+                    ambr_dl = get_bit_Rate(ptr[23]);
+                    gbr_ul = get_bit_Rate(ptr[24]);
+                    gbr_dl = get_bit_Rate(ptr[25]);
+                }
+            }
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   45282  bearer_msg_type %d, bearer_id %d, bearer_type %d, qci %d \n",bearer_msg_type, bearer_id, bearer_type, qci);
+            break;
+        case 45427:
+             QCRIL_LOG_INFO(" QCRIL_DIAG:   45427  diag_log_stream_config  0xB173  LTE PDSCH Stat Indication  \n");
+            int bler_pkt_len = ptr[13];
+            int index = 22;
+            int i ;
+            for (i=0;i< bler_pkt_len;i++) {
+               if(ptr[index] & 0x80) {
+                    crc_pass++;
+                    //QCRIL_LOG_INFO(" QCRIL_DIAG:   45427  diag_log_stream_config  crc_pass %d\n", crc_pass);
+                } else {
+                    crc_fail++;
+                    //QCRIL_LOG_INFO(" QCRIL_DIAG:   45427  diag_log_stream_config  crc_fail %d\n", crc_fail);
+
+                }
+               index+=20;
+            }
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   45427  diag_log_stream_config  crc_pass %d, crc_fail %d\n", crc_pass,crc_fail);
+        break;
+        case 6192:
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   6192  diag_log_stream_config   IMS VoLTE Session Setup (0x1830) \n");
+            local_counter = sequence_number;
+            if(!in_call) {
+                extra_short_mute = 0;
+                short_mute = 0;
+                medium_mute = 0;
+                long_mute = 0;
+                crc_pass = 0;
+                crc_fail = 0;
+                rtp_packet_loss = 0;
+                total_loss_rtp_pckt_cnt = 0;
+                total_rtp_pckt_cnt = 0;
+                temp_rankIndicator = 0; //Let retrieve rank indicator again in 0xB14D
+                //enabling bler log packet during call
+                err = diag_log_stream_config(client_id, ENABLE, log_codes_array_bler,1);
+                if (err != DIAG_DCI_NO_ERROR) {
+                    QCRIL_LOG_INFO(" Error sending diag_log_stream_config - log_codes_array_bler to peripheral, err: %d, errno: %d\n", err, errno);
+                }
+            }
+            in_call = 1;
+            break;
+        case 6193:
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   6193  diag_log_stream_config   IMS VoLTE Session End (0x1831) \n");
+            local_counter = sequence_number;
+            QCRIL_LOG_INFO(" QCRIL_DIAG:   6192  diag_log_stream_config  short_mute %d  medium_mute %d  long_mute %d \n",short_mute,medium_mute,long_mute);
+            in_call = 0;
+            if(crc_fail > 0) {
+                if(crc_pass > 0) {
+                    bler = 100*crc_fail/(crc_fail+crc_pass);
+                    QCRIL_LOG_INFO(" QCRIL_DIAG:   45427  bler:  %d \n",bler);
+                } else {
+                    bler = 100;
+                    QCRIL_LOG_INFO(" QCRIL_DIAG:   45427  bler:  %d \n",bler);
+                }
+            }
+            if ((total_rtp_pckt_cnt > 0 ) && (total_loss_rtp_pckt_cnt > 0)) {
+                rtp_packet_loss = 100*total_loss_rtp_pckt_cnt/(total_loss_rtp_pckt_cnt+total_rtp_pckt_cnt);
+            }
+
+            //Disabling bler log packet during call
+            err = diag_log_stream_config(client_id, DISABLE, log_codes_array_bler,1);
+            if (err != DIAG_DCI_NO_ERROR) {
+                QCRIL_LOG_INFO(" Error sending diag_log_stream_config - log_codes_array_bler to peripheral, err: %d, errno: %d\n", err, errno);
+            }
+            break;
+
+        case 5529:
+             QCRIL_LOG_INFO(" QCRIL_DIAG:   5529  diag_log_stream_config  GNSS LOC LTE OTDOA PRS RSTD MEAS (0x1599)  \n");
+            int ngbr_cell_len = ptr[17];
+                    QCRIL_LOG_INFO(" QCRIL_DIAG:   5529  ngbr_cell_len  rstd[i] %d\n", ngbr_cell_len);
+
+            int flag_mask = 0x10 & (*(uint32 *)(ptr + 86));
+                    QCRIL_LOG_INFO(" QCRIL_DIAG:   5529  diag_log_stream_config   %d  flag_mask , %d\n", *(int *)(ptr + 86),flag_mask);
+            index = 110;
+            for (i=0;i< ngbr_cell_len && (i < 3);i++) {
+               if(flag_mask) {
+                    rstd[i]= *(uint16 *)(ptr + index);
+                    QCRIL_LOG_INFO(" QCRIL_DIAG:   5529  diag_log_stream_config  rstd[i] %d\n", rstd[i]);
+                } else {
+                    rstd[i]= 0;
+                    printf(" QCRIL_DIAG:   5529  diag_log_stream_config  rstd[i] %d\n", rstd[i]);
+               }
+               index+=68;
+            }
+
+        default:
+            QCRIL_LOG_INFO(" default sending diag_log_stream_config - SET_LOG_MASK to peripheral \n")
+
+        break;
+    };
+
+
+}
+
+void process_dci_event_stream(unsigned char *ptr, int len)
+{
+    (void)ptr;
+    int event_id = *(uint16 *)(ptr + 2);
+    event_id = 0xFFF & event_id;
+     QCRIL_LOG_INFO(" process_dci_event_stream: Received an after event Id : %d   of size %d bytes \n" ,event_id , len);
+    print_bytes(ptr, len, FALSE);
+    dataCollectorEvents = 0;
+    switch (event_id) {
+        case EVENT_LTE_RRC_RADIO_LINK_FAILURE :
+             QCRIL_LOG_INFO(" diag_event_stream_config EVENT_LTE_RRC_RADIO_LINK_FAILURE (ID=1608)l \n");
+            temp_rankIndicator = 0; //Let retrieve rank indicator again in 0xB14D
+            dataCollectorEvents = DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE;
+            QCRIL_LOG_INFO ("data collector indication - %d", dataCollectorEvents);
+            break;
+        case EVENT_LTE_RRC_NEW_CELL_IND :
+            //LTE ML1 Handover Timeline Info (0xB1D9)
+             QCRIL_LOG_INFO(" diag_event_stream_config   EVENT_LTE_RRC_NEW_CELL_IND  reason %d  frequency %d \n",ptr[13],*(uint16 *)(ptr + 14));
+            if(ptr[13]==1){
+            dataCollectorEvents = DATA_COLLECTOR_EVENT_CELL_RESELECTION;
+            QCRIL_LOG_INFO ("data collector indication - %d", dataCollectorEvents);
+            } else if(ptr[13]==2){
+                if(frequeny != *(uint16 *)(ptr + 14)) {
+                    frequeny = *(uint16 *)(ptr + 14);
+                    dataCollectorEvents = DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER;
+                    QCRIL_LOG_INFO ("data collector indication - %d", dataCollectorEvents);
+                }else {
+                    dataCollectorEvents = DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER;
+                    QCRIL_LOG_INFO ("data collector indication - %d", dataCollectorEvents);
+                }
+            }
+            break;
+        case EVENT_LTE_RACH_ACCESS_START:
+             rach_cause = ptr[12];
+             QCRIL_LOG_INFO(" diag_event_stream_config   EVENT_LTE_RACH_ACCESS_START RACH cause %d \n" , rach_cause);
+            break;
+        case EVENT_LTE_RACH_ACCESS_RESULT :
+             QCRIL_LOG_INFO(" diag_event_stream_config   EVENT_LTE_RACH_ACCESS_RESULT failure %d \n" , ptr[12]);
+             if(rach_cause == 4 && ptr[12]==1){ //rach_cause handover(4) and RACH was successful(1). FYI: rach_cause(0) connection request, 2 = UL data arrival
+                 rach_cause = -1;
+                 dataCollectorEvents = DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER;
+                 QCRIL_LOG_INFO ("data collector indication - %d", dataCollectorEvents);
+             } else if(ptr[12]==3 || ptr[12]==2){ //RACH was Failed(3) or RACH has a problem(2); RACH was aborted(0), not include as failed
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_RACH_FAILURE;
+                QCRIL_LOG_INFO(" data collector indication - %d", dataCollectorEvents);
+            }
+            break;
+        case EVENT_LTE_EMM_OTA_OUTGOING_MSG :
+             QCRIL_LOG_INFO(" diag_event_stream_config   EVENT_LTE_EMM_OTA_OUTGOING_MSG  request type %d \n" , ptr[12]);
+            if(ptr[12]==65){
+                number_of_attach++;
+                incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_ATTACH);
+                QCRIL_LOG_INFO(" data collector number_of_attach - %d", number_of_attach);
+            } else if(ptr[12]==69) {
+                number_of_detach++;
+                temp_rankIndicator = 0; //Let retrieve rank indicator again in 0xB14D at APM ON/OFF, detach.
+                incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_DETACH);
+                QCRIL_LOG_INFO(" data collector number_of_detach - %d", number_of_detach);
+            }
+            break;
+        default:
+             QCRIL_LOG_INFO(" default sending diag_event_stream_config - SET_LOG_MASK to peripheral \n")
+            dataCollectorEvents = -1;
+            return;
+        break;
+    };
+    if(dataCollectorEvents > 0) {
+        qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+    }
+}
+
+void incrementPersistStorage(char *property) {
+    char existingValue[PROPERTY_VALUE_MAX];
+    property_get(property,existingValue,"");
+    int existingValueInt = atoi(existingValue);
+    existingValueInt++;
+    char valueStr[16];
+    sprintf(valueStr, "%d", existingValueInt);
+    property_set(property, valueStr);
+}
+void process_response(unsigned char *ptr, int len, void *data_ptr)
+{
+    int i = 0;
+    uint8 operation = 0;
+    (void)data_ptr;
+
+    if (!ptr || len < 0)
+        return;
+
+    QCRIL_LOG_INFO("Received Response of size %d bytes.\n", len);
+    print_bytes(ptr, len, FALSE);
+
+    /* Parsing Logic for the response - Based on the request in this sample */
+    if (len <= DIAG_STRESS_TEST_OP_IDX)
+        return;
+
+    operation = ptr[DIAG_STRESS_TEST_OP_IDX];
+    if (ptr[DIAG_CMD_CODE_IDX] == DIAG_SUBSYS_CMD_F &&
+        ptr[DIAG_SUBSYS_ID_IDX] == DIAG_SUBSYS_DIAG_SERV) {
+        QCRIL_LOG_INFO("  Command Code:   Diag\n");
+        QCRIL_LOG_INFO("  Subsystem ID:   Diag\n");
+        if (operation <= DIAGDIAG_STRESS_TEST_ERR_FATAL) {
+            QCRIL_LOG_INFO("  Test for:       F3s\n");
+        } else if (operation == DIAGDIAG_STRESS_TEST_LOG) {
+            QCRIL_LOG_INFO("  Test for:       Logs\n");
+        } else if (operation == DIAGDIAG_STRESS_TEST_EVENT_NO_PAYLOAD) {
+            QCRIL_LOG_INFO("  Test for:       Events without payload\n");
+        } else if (operation == DIAGDIAG_STRESS_TEST_EVENT_WITH_PAYLOAD) {
+            QCRIL_LOG_INFO("  Test for:       Events with payload\n");
+        }
+    }
+    printf("\n");
+}
+
+/* Signal handler that handles the change in DCI channel */
+void notify_handler(int signal, siginfo_t *info, void *unused)
+{
+    (void)unused;
+
+    if (info) {
+        int err;
+        diag_dci_peripherals list = 0;
+
+        QCRIL_LOG_INFO("diag: In %s, signal %d received from kernel, data is: %x\n",
+            __func__, signal, info->si_int);
+
+        if (info->si_int & DIAG_STATUS_OPEN) {
+            if (info->si_int & DIAG_CON_MPSS) {
+                QCRIL_LOG_INFO("diag: DIAG_STATUS_OPEN on DIAG_CON_MPSS\n");
+            } else if (info->si_int & DIAG_CON_LPASS) {
+                QCRIL_LOG_INFO("diag: DIAG_STATUS_OPEN on DIAG_CON_LPASS\n");
+            } else {
+                QCRIL_LOG_INFO("diag: DIAG_STATUS_OPEN on unknown peripheral\n");
+            }
+        } else if (info->si_int & DIAG_STATUS_CLOSED) {
+            if (info->si_int & DIAG_CON_MPSS) {
+                QCRIL_LOG_INFO("diag: DIAG_STATUS_CLOSED on DIAG_CON_MPSS\n");
+            } else if (info->si_int & DIAG_CON_LPASS) {
+                QCRIL_LOG_INFO("diag: DIAG_STATUS_CLOSED on DIAG_CON_LPASS\n");
+            } else {
+                QCRIL_LOG_INFO("diag: DIAG_STATUS_CLOSED on unknown peripheral\n");
+            }
+        }
+        err = diag_get_dci_support_list_proc(MSM, &list);
+        if (err != DIAG_DCI_NO_ERROR) {
+            QCRIL_LOG_INFO("diag: could not get support list, err: %d\n", err);
+        }
+        /* This will print out all peripherals supporting DCI */
+        if (list & DIAG_CON_MPSS)
+            QCRIL_LOG_INFO("diag: Modem supports DCI\n");
+        if (list & DIAG_CON_LPASS)
+            QCRIL_LOG_INFO("diag: LPASS supports DCI\n");
+        if (list & DIAG_CON_WCNSS)
+            QCRIL_LOG_INFO("diag: RIVA supports DCI\n");
+        if (list & DIAG_CON_APSS)
+            QCRIL_LOG_INFO("diag: APSS supports DCI\n");
+        if (!list)
+            QCRIL_LOG_INFO("diag: No current dci support\n");
+    } else {
+        QCRIL_LOG_INFO("diag: In %s, signal %d received from kernel, but no info value, info: 0x%p\n",
+            __func__, signal, info);
+    }
+}
+
+/* Singal Handler that will be fired when we receive DCI data */
+void dci_data_handler(int signal)
+{
+    (void)signal;
+
+    QCRIL_LOG_INFO("diag: dci_data_handler\n");
+    /* Do something here when you receive DCI data. */
+
+    /* This is usually for holding wakelocks when the
+       clients are running in Diag Non Real Time mode
+       or when they know the Apps processor is in deep
+       sleep but they still need to process DCI data.
+
+       Please Note: Wakelocks must be released
+       after processing the data in the respective
+       response/log/event handler. Failure to do so
+       will affect the power consumption of the Apps
+       processor. */
+}
+
+void qcril_diag_nas_get_nw_data_collector_params_req(qmi_ril_nw_data_collector_Param* diag_ril_nw_data_collector_Params){
+    QCRIL_LOG_INFO("qcril_diag_nas_get_nw_data_collector_params_req");
+    QCRIL_LOG_INFO("45459 diag_log_stream_config enabling 0xB14D  LTE LL1 PUCCH CSF – periodic 0xB14E  LTE LL1 PUSCH CSF – aperiodic \n");
+    err = diag_log_stream_config(client_id, ENABLE, log_codes_array_cqi,1);
+    if (err != DIAG_DCI_NO_ERROR) {
+        QCRIL_LOG_INFO(" Error sending diag_log_stream_config - SET_LOG_MASK to peripheral, err: %d, errno: %d\n", err, errno);
+    }
+
+    diag_ril_nw_data_collector_Params->cqi = cqi;
+    diag_ril_nw_data_collector_Params->rankIndicator = rankIndicator;
+    diag_ril_nw_data_collector_Params->rrc_conn_cause = rrc_conn_cause;
+    diag_ril_nw_data_collector_Params->rrc_rel_cause = rrc_rel_cause;
+    diag_ril_nw_data_collector_Params->prach_tx_power = prach_tx_power;
+    diag_ril_nw_data_collector_Params->total_rtp_loss = total_rtp_loss;
+    diag_ril_nw_data_collector_Params->tac_fail_cause = tac_fail_cause;
+    diag_ril_nw_data_collector_Params->number_of_attach = number_of_attach;
+    diag_ril_nw_data_collector_Params->number_of_attach_fail = number_of_attach_fail;
+    diag_ril_nw_data_collector_Params->attach_fail_cause = attach_reject_cause;
+    diag_ril_nw_data_collector_Params->number_of_detach = number_of_detach;
+    diag_ril_nw_data_collector_Params->bearer_id = bearer_id;
+    diag_ril_nw_data_collector_Params->bearer_type = bearer_type;
+    diag_ril_nw_data_collector_Params->qci = qci;
+    diag_ril_nw_data_collector_Params->ambr_ul = ambr_ul;
+    diag_ril_nw_data_collector_Params->ambr_dl = ambr_dl;
+    diag_ril_nw_data_collector_Params->gbr_ul = gbr_ul;
+    diag_ril_nw_data_collector_Params->gbr_dl = gbr_dl;
+    diag_ril_nw_data_collector_Params->bler = bler;
+    diag_ril_nw_data_collector_Params->rstd0 = rstd[0];
+    diag_ril_nw_data_collector_Params->rstd1 = rstd[1];
+    diag_ril_nw_data_collector_Params->rstd2 = rstd[2];
+    diag_ril_nw_data_collector_Params->rtp_packet_loss = rtp_packet_loss;
+    diag_ril_nw_data_collector_Params->mute[0] = extra_short_mute;
+    diag_ril_nw_data_collector_Params->mute[1] = short_mute;
+    diag_ril_nw_data_collector_Params->mute[2] = medium_mute;
+    diag_ril_nw_data_collector_Params->mute[3] = long_mute;
+
+return;
+}
+
+// Init qcril_diag
+int init_qcril_diag()
+{
+     QCRIL_LOG_INFO(" init_qcril_diag \n");
+    int signal_type = SIGCONT;
+    boolean bInit_success = FALSE;
+    diag_dci_peripherals list = DIAG_CON_MPSS;
+
+    /* Signal handling to handle SSR */
+    struct sigaction notify_action;
+    sigemptyset(&notify_action.sa_mask);
+    notify_action.sa_sigaction = notify_handler;
+    /* Use SA_SIGINFO to denote we are expecting data with the signal */
+    notify_action.sa_flags = SA_SIGINFO;
+    sigaction(signal_type, &notify_action, NULL);
+
+    /* Signal handling for DCI Data */
+    struct sigaction dci_data_action;
+    sigemptyset(&dci_data_action.sa_mask);
+    dci_data_action.sa_handler = dci_data_handler;
+    dci_data_action.sa_flags = 0;
+    sigaction(DIAG_SAMPLE_SIGNAL, &dci_data_action, NULL);
+
+    /* Registering with Diag which gives the client a handle to the Diag driver */
+    bInit_success = Diag_LSM_Init(NULL);
+    if (!bInit_success) {
+        QCRIL_LOG_INFO(" Couldn't register with Diag LSM, errno: %d\n", errno);
+        return -1;
+    }
+
+    dci_rsp_pkt = (unsigned char *)malloc(DIAG_MAX_RX_PKT_SIZ);
+    if (!dci_rsp_pkt) {
+        QCRIL_LOG_INFO("  Unable to allocate memory for DCI rsp pkt, errno: %d", errno);
+        return -1;
+    }
+
+    /* Registering with DCI - This assigns a client ID */
+    /* Channel 0 - MSM, 1 - MDM */
+    err = diag_register_dci_client(&client_id, &list, channel, &signal_type);
+    if (err != DIAG_DCI_NO_ERROR) {
+        QCRIL_LOG_INFO(" Could not register with DCI, err: %d, errno: %d\n", err, errno);
+        free(dci_rsp_pkt);
+        return -1;
+    } else
+        QCRIL_LOG_INFO(" Successfully registered with DCI, client ID = %d\n", client_id);
+
+    err = diag_register_dci_signal_data(client_id, DIAG_SAMPLE_SIGNAL);
+    if (err != DIAG_DCI_NO_ERROR) {
+        QCRIL_LOG_INFO(" Could not register signal for DCI Data, err: %d, errno: %d\n", err, errno);
+        free(dci_rsp_pkt);
+        return -1;
+    }
+
+    /* Getting supported Peripherals list*/
+    QCRIL_LOG_INFO(" DCI Status on Processors:\n");
+    err = diag_get_dci_support_list_proc(channel, &list);
+    if (err != DIAG_DCI_NO_ERROR) {
+        printf(" Could not get support list, err: %d, errno: %d\n", err, errno);
+        free(dci_rsp_pkt);
+        return -1;
+    }
+    QCRIL_LOG_INFO("   MPSS:\t ");
+    QCRIL_LOG_INFO((list & DIAG_CON_MPSS) ? "UP\n" : "DOWN\n");
+
+
+    /* Initializing Log and Event streaming by registering
+       listeners - This is required to receive Logs and Events */
+    QCRIL_LOG_INFO(" Opening Data Stream, registering listeners\n");
+    err = diag_register_dci_stream_proc(client_id, process_dci_log_stream, process_dci_event_stream);
+    if (err != DIAG_DCI_NO_ERROR)
+        QCRIL_LOG_INFO(" Unable to register DCI stream, err: %d, errno: %d\n", err, errno);
+
+    /* Registering unsol diag event */
+
+    err = diag_log_stream_config(client_id, ENABLE, log_codes_array,TOTAL_LOG_CODES);
+    if (err != DIAG_DCI_NO_ERROR) {
+        QCRIL_LOG_INFO(" Error sending diag_log_stream_config - log_codes_array to peripheral, err: %d, errno: %d\n", err, errno);
+    }
+
+
+    err = diag_event_stream_config(client_id, ENABLE, event_codes_array, TOTAL_EVENT_CODES);
+    if (err != DIAG_DCI_NO_ERROR) {
+         QCRIL_LOG_INFO(" QCRIL_DIAG:   Error sending SET_EVENT_MASK to peripheral, err: %d, errno: %d\n", err, errno);
+    }
+
+    err = diag_log_stream_config(client_id, ENABLE, log_codes_array_cqi,1);
+    if (err != DIAG_DCI_NO_ERROR) {
+        QCRIL_LOG_INFO(" Error sending diag_log_stream_config - SET_LOG_MASK to peripheral, err: %d, errno: %d\n", err, errno);
+    }
+
+    printf("init_qcril_diag done \n");
+    return 0;
+}
+
+void Dinit_qcril_diag(){
+
+    QCRIL_LOG_INFO(" Releasing DCI connection \n");
+    err = diag_release_dci_client(&client_id);
+    if (err != DIAG_DCI_NO_ERROR)
+        QCRIL_LOG_INFO(" Error releasing DCI connection, err: %d, errno: %d\n", err, errno);
+
+    Diag_LSM_DeInit();
+    printf("\n");
+    free(dci_rsp_pkt);
+
+}
+
+int get_bit_Rate(int value){
+    char x_int = value;
+    if(x_int < 64){
+        x_int = x_int;
+    }else if(x_int < 128){
+       x_int = (x_int-64)*8 + 64;
+    }else{
+        if(x_int == 255){
+            x_int = 0;
+        }else{
+            x_int = (x_int-128)*64 + 576;
+        }
+    }
+return x_int;
+}
diff --git a/qcril/data_collector/qcril_diag.h b/qcril/data_collector/qcril_diag.h
new file mode 100644
index 0000000..17d2f4c
--- /dev/null
+++ b/qcril/data_collector/qcril_diag.h
@@ -0,0 +1,50 @@
+#ifndef QCRIL_DIAG_H
+#define QCRIL_DIAG_H
+
+/*==========================================================================
+
+                     Diag Client Main Task Header File
+
+Description
+  Global Data declarations of the Diag client.
+
+=========================================================================== */
+
+#include "event.h"
+#include "msg.h"
+#include "log.h"
+#include "diag_lsm.h"
+#include "../../diag/src/diag_lsmi.h"
+#include "diag_lsm_dci.h"
+#include "../../diag/src/diag_shared_i.h"
+#include "stdio.h"
+#include "string.h"
+#include "malloc.h"
+#include "diagpkt.h"
+#include <errno.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/klog.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <sys/time.h>
+#include "../../diag/src/diagdiag.h"    /* For macros used in this sample. */
+#include "qcrili.h"
+#include <cutils/properties.h>
+
+#define TRUE 1
+#define FALSE 0
+
+#define TOTAL_DC_EVENT_CODES  9
+#define TOTAL_DC_LOG_CODES 9
+#define TOTAL_LOG_CODES_APPS    3
+#define DIAG_SAMPLE_SIGNAL    SIGRTMIN + 15
+
+#define DIAG_CMD_CODE_IDX        0
+#define DIAG_SUBSYS_ID_IDX        1
+#define DIAG_STRESS_TEST_OP_IDX        8
+
+int init_qcril_diag(void);
+void qcril_diag_nas_get_nw_data_collector_params_req(qmi_ril_nw_data_collector_Param* diag_ril_nw_data_collector_Params);
+#endif
\ No newline at end of file
diff --git a/qcril/qcril_qmi/ims_socket/qcril_qmi_ims_misc.c b/qcril/qcril_qmi/ims_socket/qcril_qmi_ims_misc.c
index 593823b..d448767 100755
--- a/qcril/qcril_qmi/ims_socket/qcril_qmi_ims_misc.c
+++ b/qcril/qcril_qmi/ims_socket/qcril_qmi_ims_misc.c
@@ -22,6 +22,8 @@
 
 #define WLAN_HANDOVER_NO_LTE_FAILURE_CODE_STRING "CD-04"
 
+uint8_t dataCollectorEvents_ims = -1;
+int volte_reg_state_cache = -1;
 //===========================================================================
 // qcril_qmi_ims_map_event_to_request
 //===========================================================================
@@ -1268,6 +1270,28 @@ ims_Info* qcril_qmi_ims_create_ims_info(
                 ims_info_ptr->accTechStatus.arg)[0]->registered.has_state,
                 ((ims_StatusForAccessTech**)
                 ims_info_ptr->accTechStatus.arg)[0]->registered.state );
+
+        QCRIL_LOG_INFO("VoLTE reg state indication: volte_reg_state_cache = %d", volte_reg_state_cache);
+        if((ims_info_ptr->callType == ims_CallType_CALL_TYPE_VOICE) && ((ims_StatusForAccessTech**)ims_info_ptr->accTechStatus.arg)[0]->has_status &&
+                (ims_StatusType_STATUS_ENABLED == ((ims_StatusForAccessTech**)ims_info_ptr->accTechStatus.arg)[0]->status ||
+                ims_StatusType_STATUS_PARTIALLY_ENABLED == ((ims_StatusForAccessTech**)ims_info_ptr->accTechStatus.arg)[0]->status)) {
+            if (volte_reg_state_cache != 0) {
+                dataCollectorEvents_ims = DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT;
+                //send imsa service state unsol from here.
+                QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents_ims);
+                volte_reg_state_cache = 0;
+                qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents_ims, sizeof(dataCollectorEvents_ims));
+            }
+        } else if ((ims_info_ptr->callType == ims_CallType_CALL_TYPE_VOICE) && ((ims_StatusForAccessTech**)ims_info_ptr->accTechStatus.arg)[0]->has_status &&
+                (ims_StatusType_STATUS_DISABLED == ((ims_StatusForAccessTech**)ims_info_ptr->accTechStatus.arg)[0]->status)) {
+            if (volte_reg_state_cache != 2) {
+                dataCollectorEvents_ims = DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST;
+                //send imsa service state unsol from here.
+                volte_reg_state_cache = 2;
+                QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents_ims);
+                qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents_ims, sizeof(dataCollectorEvents_ims));
+            }
+        }
     }
     return ims_info_ptr;
 } // qcril_qmi_ims_create_ims_info
diff --git a/qcril/qcril_qmi/qcril.c b/qcril/qcril_qmi/qcril.c
index a94acf0..da60a00 100755
--- a/qcril/qcril_qmi/qcril.c
+++ b/qcril/qcril_qmi/qcril.c
@@ -78,6 +78,7 @@
 #include "qcril_qmi_radio_config_dispatch_helper.h"
 #include "qcril_qmi_radio_config_socket.h"
 
+//#include "qcril_diag.h"
 
 /*===========================================================================
 
@@ -107,6 +108,8 @@
 #define QCRIL_REG_SIM_OR_RUIM_READY_STATES( event_id, handler ) \
   NULL, (uint32) event_id, handler, QCRIL_STATE_MASK_SIM_OR_RUIM_READY_STATES
 
+#define PROP_DATA_COLLECTOR_ENABLED "persist.radio.dc.enabled"
+
 static qcril_dispatch_table_entry_type qcril_event_table[] =
 {
   /**********************************************
@@ -1834,7 +1837,8 @@ static void qmi_ril_bootup_perform_core_or_start_polling(void * params);
 static void qmi_ril_core_init_kicker_main_threaded_proc(void* empty_param);
 static void qcril_free_request_list_entry_deferred( qcril_timed_callback_handler_params_type * handler_params );
 static void qcril_print_heap_memory_list();
-
+static int  init_qcril_diag(void);
+static void Dinit_qcril_diag();
 pthread_t qmi_ril_fw_get_main_thread_id();
 
 static void qmi_ril_oem_hook_init();
@@ -6878,6 +6882,12 @@ void qcril_init
   qmi_ril_oem_hook_init();
 
   qcril_db_init();
+  char prop_str[ PROPERTY_VALUE_MAX ];
+  property_get(PROP_DATA_COLLECTOR_ENABLED,prop_str,"");
+  if(strcmp(prop_str, "true") == 0 || strcmp(prop_str, "1") == 0) {
+    QCRIL_LOG_INFO(" ril: NetworkDataCollector: Initializing qcril diag");
+    init_qcril_diag();
+  }
 
   /* ###############################################################################################
         !!!IMPORTANT!!!
@@ -7186,7 +7196,8 @@ void qcril_release
 
   /* For QMI_VOICE, NAS/DMS, WMS */
   qcril_qmi_client_release();
-
+  //realesing diag
+  Dinit_qcril_diag();
   if ( qmi_ril_is_multi_sim_feature_supported() )
   {
       qcril_ipc_release();
@@ -11463,7 +11474,6 @@ int qmi_ril_threads_shutdown()
   {
     QCRIL_LOG_ERROR("Could not successfully shutdown thread in core_handler.c");
   }
-
   return 0;
 }
 
@@ -11484,7 +11494,7 @@ int qmi_ril_reboot_cleanup()
   qmi_ril_clear_timed_callback_list();
   // clean up core clients
   qcril_qmi_client_release();
-
+  Dinit_qcril_diag();
   qmi_ril_reset_multi_sim_ftr_info();
 
   if (qcril_db_reset_cleanup() != 0)
diff --git a/qcril/qcril_qmi/qcril_qmi.mk b/qcril/qcril_qmi/qcril_qmi.mk
index 5f3bea2..6708c25 100755
--- a/qcril/qcril_qmi/qcril_qmi.mk
+++ b/qcril/qcril_qmi/qcril_qmi.mk
@@ -160,6 +160,8 @@ LOCAL_SRC_FILES += qcril_qmi/utilities/synchronization/util_synchronization.c
 LOCAL_SRC_FILES += qcril_qmi/utilities/timer/util_timer.c
 LOCAL_SRC_FILES += qcril_qmi/utilities/timer/timer_event_lookup.c
 
+LOCAL_SRC_FILES += data_collector/qcril_diag.c
+
 # for asprinf
 LOCAL_CFLAGS := -D_GNU_SOURCE
 
diff --git a/qcril/qcril_qmi/qcril_qmi_nas.c b/qcril/qcril_qmi/qcril_qmi_nas.c
index fe1c8d3..298486f 100755
--- a/qcril/qcril_qmi/qcril_qmi_nas.c
+++ b/qcril/qcril_qmi/qcril_qmi_nas.c
@@ -834,21 +834,10 @@ typedef struct
 } qmi_ril_reg_reject_cached_summary_type;
 
 int8 is_data_collector_available =1;
-
-struct qmi_ril_nw_data_collector_Param
-{
-    int32_t rsrp;
-    int32_t rsrq;
-    int32_t snr;
-    int32_t activeband;
-    uint32_t lte_earfcn;
-    int32_t  srv_status;
-    int32_t timing_advance;
-    int32_t Roaming_Indicator;
-    int32_t sip_reg_status;
-    int32_t tac;
-};
-struct qmi_ril_nw_data_collector_Param qmi_ril_nw_data_collector_Params;
+uint8_t dataCollectorEvents = -1;
+int8 service_state_cache = -1;
+int dc_rsrp_cache = -1;
+qmi_ril_nw_data_collector_Param qmi_ril_nw_data_collector_Params;
 
 typedef struct
 {
@@ -8528,12 +8517,6 @@ int qcril_qmi_nas_sys_info_ind_conv_qmi2ril(nas_sys_info_ind_msg_v01 * qmi_msg,
        *network_state_updated = ( nas_common_info.location_updates_enabled &&
                                 ( ( prev_sys_info_helper.lte_only_sys_info->tac_valid && cur_sys_info_helper.lte_only_sys_info->tac_valid ) &&
                                   ( prev_sys_info_helper.lte_only_sys_info->tac != cur_sys_info_helper.lte_only_sys_info->tac ) ) );
-       if( *network_state_updated) {
-       //sendt tac update unsol from here.
-           uint8_t dataCollectorEvents = DATA_COLLECTOR_EVENT_TAC_UPDATE;
-               QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents);
-           qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
-       }
      }
    }
    // Check for location update for CDMA
@@ -9689,6 +9672,15 @@ void qcril_qmi_nas_dump_sign_strength_report(RIL_SignalStrength* ril_signal_stre
                                                               ril_signal_strength->LTE_SignalStrength.rsrq,
                                                               ril_signal_strength->LTE_SignalStrength.rssnr );
 
+    QCRIL_LOG_INFO("qmi_ril_nw_data_collector_Params.rsrp  %d", ril_signal_strength->LTE_SignalStrength.rsrp );
+    if(ril_signal_strength->LTE_SignalStrength.rsrp > 110 && ril_signal_strength->LTE_SignalStrength.rsrp < 250 && (dc_rsrp_cache!=ril_signal_strength->LTE_SignalStrength.rsrp)) {
+      dataCollectorEvents = DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM;
+      //send ims service state unsol from here.
+      QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents);
+      qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+    }
+    dc_rsrp_cache = ril_signal_strength->LTE_SignalStrength.rsrp;
+
     QCRIL_LOG_FUNC_RETURN();
 }
 
@@ -14128,6 +14120,10 @@ void qcril_qmi_nas_request_data_registration_state
                       /* Physical Cell ID */
                       val_int = get_cell_location_info_resp.lte_intra.serving_cell_id;
                       snprintf( ril_resp_helper.phys_cell_id, sizeof(ril_resp_helper.phys_cell_id), "%d", (int) val_int);
+
+                      //update data colletor pci from here.
+                      qmi_ril_nw_data_collector_Params.pci = val_int;
+                      QCRIL_LOG_INFO("get_cell_location_info_resp successful pci = %d ", qmi_ril_nw_data_collector_Params.pci);
                   }
               }
           } // LTE specifics, if ( QCRIL_ARB_PREF_DATA_TECH_LTE == data_tech_to_report) )
@@ -14216,6 +14212,25 @@ void qcril_qmi_nas_request_data_registration_state
       // Simplified logging
       QCRIL_LOG_INFO("RIL DATA REGISTRATION: %s %s in %s", ((log_mask & 0x01)?"Full service":"No service"), ((log_mask&0x02)?"Roaming":"Home"),
                      qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
+      QCRIL_LOG_INFO("Service state indication: service_state_cache = %d", service_state_cache);
+      if (log_mask & 0x01) {
+          if (service_state_cache != 0) {
+              dataCollectorEvents = DATA_COLLECTOR_EVENT_IN_SERVICE;
+              service_state_cache = 0;
+              //send ims service state unsol from here.
+              QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents);
+              qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+          }
+      } else {
+          if (service_state_cache != 2) {
+              dataCollectorEvents = DATA_COLLECTOR_EVENT_OUT_OF_SERVICE;
+              service_state_cache = 2;
+              //send ims service state unsol from here.
+              QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents);
+              qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+          }
+      }
+
       QCRIL_LOG_INFO("based on %s", (log_mask&0x04)?"QMI NAS":"QMI WDS");
 
       resp.resp_pkt = (void *) &ril_resp_helper.registration_info_array;
@@ -15493,6 +15508,12 @@ int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status( uint32_t nas_sy
                                 (int) threegpp_sys_info->reg_reject_info_valid,
                                 (int) threegpp_sys_info->reg_reject_info.reject_srv_domain,
                                 (int) threegpp_sys_info->reg_reject_info.rej_cause );
+
+            if ((int) threegpp_sys_info->reg_reject_info_valid == 1) {
+                QCRIL_LOG_INFO ("Send unsol reject cause = %d ", threegpp_sys_info->reg_reject_info.rej_cause);
+                //send attach failure update unsol from here.
+                qmi_ril_nw_data_collector_Params.attach_fail_cause = (int) threegpp_sys_info->reg_reject_info.rej_cause;
+            }
         }
         if ( threegpp_status_info != NULL )
         {
@@ -26999,10 +27020,18 @@ unsigned qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo
   RIL_CellInfo *curr_cel = NULL, *srv_cell = NULL;
   unsigned ret =0;
   unsigned i = 0, j;
+  unsigned cells_len = 0;
+  qmi_ril_nw_data_collector_Params.number_of_cells = 0;
 
   if (li && ril_info && *ril_info && timestamp && ril_info_items > 0)
   {
     curr_cel = *ril_info;
+    int count;
+    for (count = 0; count < 12; count++) {
+     qmi_ril_nw_data_collector_Params.cells[count][0] = 0;
+     qmi_ril_nw_data_collector_Params.cells[count][1] =  0xffff;
+     qmi_ril_nw_data_collector_Params.cells[count][2] = 0xffff;
+    }
 
     if ( li->lte_intra_valid )
     {
@@ -27083,6 +27112,16 @@ unsigned qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo
                   li->lte_intra.cells[i].srxlev,
                   curr_cel->CellInfo.lte.signalStrengthLte.signalStrength);
 
+          if (cells_len > 11) cells_len = 0;
+          qmi_ril_nw_data_collector_Params.cells[cells_len][0] = li->lte_intra.cells[i].pci;
+          qmi_ril_nw_data_collector_Params.cells[cells_len][1] =  -(li->lte_intra.cells[i].rsrp / 10);
+          qmi_ril_nw_data_collector_Params.cells[cells_len][2] = -(li->lte_intra.cells[i].rsrq / 10);
+          cells_len++;
+          if (qmi_ril_nw_data_collector_Params.number_of_cells < 12) {
+              qmi_ril_nw_data_collector_Params.number_of_cells++;
+          }
+
+
           ++(*ril_info);
           curr_cel = (*ril_info);
           ret ++;
@@ -27132,6 +27171,14 @@ unsigned qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo
                   li->lte_intra.cells[i].srxlev,
                   curr_cel->CellInfo.lte.signalStrengthLte.signalStrength);
 
+          if (cells_len > 11) cells_len = 0;
+          qmi_ril_nw_data_collector_Params.cells[cells_len][0] = li->lte_inter.freqs[i].cells[j].pci;
+          qmi_ril_nw_data_collector_Params.cells[cells_len][1] = -(li->lte_inter.freqs[i].cells[j].rsrp / 10);
+          qmi_ril_nw_data_collector_Params.cells[cells_len][2] = -(li->lte_inter.freqs[i].cells[j].rsrq / 10);
+          cells_len++;
+          if (qmi_ril_nw_data_collector_Params.number_of_cells < 12) {
+              qmi_ril_nw_data_collector_Params.number_of_cells++;
+          }
           ++(*ril_info);
           curr_cel = (*ril_info);
           ret ++;
@@ -43924,7 +43971,6 @@ static void qcril_qmi_nas_send_request_reponse
     QCRIL_LOG_FUNC_RETURN();
 }
 
-
 void qcril_qmi_nas_get_nw_data_collector_params_req
 (
   const qcril_request_params_type *const params_ptr,
@@ -43983,6 +44029,61 @@ void qcril_qmi_nas_get_nw_data_collector_params_req
                 {
                     qmi_ril_nw_data_collector_Params.timing_advance = get_cell_info_resp.timing_advance;
                 }
+                int cells_len = 0;
+                int iter_j;
+                QCRIL_LOG_ERROR("get neighbor Cell info lte_intra_valid %d lte_intra.cells_len %d", get_cell_info_resp.lte_intra_valid,get_cell_info_resp.lte_intra.cells_len);
+                if(get_cell_info_resp.lte_intra_valid && get_cell_info_resp.lte_intra.cells_len <= NAS_MAX_LTE_NGBR_NUM_CELLS_V01) {
+                    int count;
+                    //Reset earlier values
+                    for (count = 0; count < 12; count++) {
+                        qmi_ril_nw_data_collector_Params.cells[count][0] = 0;
+                        qmi_ril_nw_data_collector_Params.cells[count][1] = 0;
+                        qmi_ril_nw_data_collector_Params.cells[count][2] = 0;
+                    }
+                    qmi_ril_nw_data_collector_Params.number_of_cells = 0; // Reset number of cells
+                    for (iter_j=0; iter_j < get_cell_info_resp.lte_intra.cells_len; iter_j++ )
+                    {
+                      if (qmi_ril_nw_data_collector_Params.pci != get_cell_info_resp.lte_intra.cells[iter_j].pci)
+                      { // Don't copy serving cell info
+                        if (cells_len > 11) cells_len = 0;
+                        qmi_ril_nw_data_collector_Params.cells[cells_len][0] = get_cell_info_resp.lte_intra.cells[iter_j].pci;
+                        qmi_ril_nw_data_collector_Params.cells[cells_len][1] =  140 + (get_cell_info_resp.lte_intra.cells[iter_j].rsrp / 10);
+                        qmi_ril_nw_data_collector_Params.cells[cells_len][2] = 20 + (get_cell_info_resp.lte_intra.cells[iter_j].rsrq / 10);
+                        QCRIL_LOG_ERROR("Intra neighbor Cell info pci %d rsrp %d rsrq %d", qmi_ril_nw_data_collector_Params.cells[cells_len][0],qmi_ril_nw_data_collector_Params.cells[cells_len][1],qmi_ril_nw_data_collector_Params.cells[cells_len][2]);
+                        cells_len++;
+                        qmi_ril_nw_data_collector_Params.number_of_cells = cells_len;
+                        if (qmi_ril_nw_data_collector_Params.number_of_cells > 12) {
+                            qmi_ril_nw_data_collector_Params.number_of_cells == 12;
+                        }
+                      }
+                    }
+                }
+                if ( get_cell_info_resp.lte_inter_valid && get_cell_info_resp.lte_inter.freqs_len <= NAS_MAX_LTE_NGBR_NUM_FREQS_V01)
+                {
+                    for (iter_j=0; iter_j < get_cell_info_resp.lte_inter.freqs_len; iter_j++)
+                    {
+                      QCRIL_LOG_ERROR("get neighbor Cell info lte_inter_valid %d lte_inter.cells_len %d", get_cell_info_resp.lte_inter_valid,get_cell_info_resp.lte_inter.freqs[iter_j].cells_len);
+                      if(get_cell_info_resp.lte_inter_valid && get_cell_info_resp.lte_inter.freqs[iter_j].cells_len <= NAS_MAX_LTE_NGBR_NUM_CELLS_V01) {
+                      int iter_k;
+                        for (iter_k=0; iter_k < get_cell_info_resp.lte_inter.freqs[iter_j].cells_len; iter_k++ )
+                        {
+                          if (qmi_ril_nw_data_collector_Params.pci != get_cell_info_resp.lte_inter.freqs[iter_j].cells[iter_k].pci)
+                          {
+                            if (cells_len > 11) cells_len = 0;
+                            qmi_ril_nw_data_collector_Params.cells[cells_len][0] = get_cell_info_resp.lte_inter.freqs[iter_j].cells[iter_k].pci;
+                            qmi_ril_nw_data_collector_Params.cells[cells_len][1] =  140 + (get_cell_info_resp.lte_inter.freqs[iter_j].cells[iter_k].rsrp / 10);
+                            qmi_ril_nw_data_collector_Params.cells[cells_len][2] = 20 + (get_cell_info_resp.lte_inter.freqs[iter_j].cells[iter_k].rsrq / 10);
+                            QCRIL_LOG_ERROR("Inter neighbor Cell info pci %d rsrp %d rsrq %d", qmi_ril_nw_data_collector_Params.cells[cells_len][0],qmi_ril_nw_data_collector_Params.cells[cells_len][1],qmi_ril_nw_data_collector_Params.cells[cells_len][2]);
+                            cells_len++;
+                            qmi_ril_nw_data_collector_Params.number_of_cells = cells_len;
+                            if (qmi_ril_nw_data_collector_Params.number_of_cells > 12) {
+                                qmi_ril_nw_data_collector_Params.number_of_cells == 12;
+                            }
+                          }
+                        }
+                      }
+                    }
+                }
                 is_data_collector_available = 1;
             }
         }
@@ -44036,19 +44137,21 @@ void qcril_qmi_nas_get_nw_data_collector_params_req
    if ( RIL_E_SUCCESS == ril_req_res )
    {
            if (is_data_collector_available == 1)
-                   {
-                           is_data_collector_available = 0;
+           {
+               is_data_collector_available = 0;
                 if (qmi_response_sig_info.lte_sig_info_valid) {
                     qmi_ril_nw_data_collector_Params.rsrp = qmi_response_sig_info.lte_sig_info.rsrp;
                     qmi_ril_nw_data_collector_Params.rsrq = qmi_response_sig_info.lte_sig_info.rsrq;
-                    qmi_ril_nw_data_collector_Params.snr = qmi_response_sig_info.lte_sig_info.snr;
+                    qmi_ril_nw_data_collector_Params.sinr = qmi_response_sig_info.lte_sig_info.snr;
                 } else {
                    QCRIL_LOG_ERROR("get QMI_NAS_GET_SIG_INFO_REQ_MSG_V01 invalid lte sig info ");
+                   dc_rsrp_cache = -1;
                 }
                 is_data_collector_available = 1;
            }
    } else {
        QCRIL_LOG_ERROR("get QMI_NAS_GET_SIG_INFO_REQ_MSG_V01 status error %d", ril_req_res);
+       dc_rsrp_cache = -1;
    }
 
     qmi_serving_system_response = qcril_malloc( sizeof( *qmi_serving_system_response ) );
@@ -44124,6 +44227,66 @@ void qcril_qmi_nas_get_nw_data_collector_params_req
        }
    }
 
+
+   nas_get_tx_rx_info_req_msg_v01 tx_rx_req;
+   nas_get_tx_rx_info_resp_msg_v01 tx_rx_resp;
+   memset( &tx_rx_req, 0, sizeof(tx_rx_req) );
+   memset( &tx_rx_resp, 0, sizeof(tx_rx_resp) );
+   tx_rx_req.radio_if = NAS_RADIO_IF_LTE_V01;
+   if( E_SUCCESS !=
+        qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
+                                            QMI_NAS_GET_TX_RX_INFO_REQ_MSG_V01, /* msg_id */
+                                            &tx_rx_req,                                         /* *req_c_struct */
+                                            sizeof(tx_rx_req),                                            /* req_c_struct_len */
+                                            &tx_rx_resp,                    /* *resp_c_struct */
+                                            sizeof(tx_rx_resp),              /* resp_c_struct_len */
+                                            QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
+                                            ) )
+   { /* error occurred during sending a message */
+        QCRIL_LOG_INFO(" qcril_qmi_client_send_msg_sync returned erro for Tx Power");
+   }
+   else
+   {
+        QCRIL_LOG_INFO(" get QMI_NAS_GET_TX_RX_INFO_REQ_MSG_V01 status result %d tx_rx_resp.tx.is_in_traffic %d  tx_rx_resp.tx_valid %d ", tx_rx_resp.resp.result,tx_rx_resp.tx.is_in_traffic,tx_rx_resp.tx_valid);
+       /* message sending was successful and got the response */
+       /* check for standard response */
+       if(QMI_RESULT_SUCCESS_V01 != get_ims_reg_resp.resp.result || !(tx_rx_resp.tx_valid && tx_rx_resp.tx.is_in_traffic ))
+       {
+           QCRIL_LOG_INFO(" get QMI_NAS_GET_TX_RX_INFO_REQ_MSG_V01 status error %d ", tx_rx_resp.resp.result);
+           qmi_ril_nw_data_collector_Params.tx_power = 0; //default value
+       }
+       else
+       {
+
+           qmi_ril_nw_data_collector_Params.tx_power = tx_rx_resp.tx.tx_pwr/10;
+           QCRIL_LOG_INFO(" get QMI_NAS_GET_TX_RX_INFO_REQ_MSG_V01 successful tx_power = %d ", qmi_ril_nw_data_collector_Params.tx_power);
+       }
+   }
+
+    qcril_diag_nas_get_nw_data_collector_params_req(&qmi_ril_nw_data_collector_Params );
+    QCRIL_LOG_INFO(" cqi value after %d", qmi_ril_nw_data_collector_Params.cqi);
+    QCRIL_LOG_INFO(" rankIndicator value after %d", qmi_ril_nw_data_collector_Params.rankIndicator);
+    QCRIL_LOG_INFO(" rrc_conn_cause value after %d", qmi_ril_nw_data_collector_Params.rrc_conn_cause);
+    QCRIL_LOG_INFO(" rrc_rel_cause value after %d", qmi_ril_nw_data_collector_Params.rrc_rel_cause);
+    QCRIL_LOG_INFO(" prach_tx_power value after %d", qmi_ril_nw_data_collector_Params.prach_tx_power);
+    QCRIL_LOG_INFO(" rtp_packet_loss value after %d", qmi_ril_nw_data_collector_Params.rtp_packet_loss);
+    QCRIL_LOG_INFO(" total_rtp_loss value after %d", qmi_ril_nw_data_collector_Params.total_rtp_loss);
+    QCRIL_LOG_INFO(" tac_fail_cause value after %d", qmi_ril_nw_data_collector_Params.tac_fail_cause);
+    QCRIL_LOG_INFO(" number_of_attach value after %d", qmi_ril_nw_data_collector_Params.number_of_attach);
+    QCRIL_LOG_INFO(" number_of_attach_fail value after %d", qmi_ril_nw_data_collector_Params.number_of_attach_fail);
+    QCRIL_LOG_INFO(" number_of_detach value after %d", qmi_ril_nw_data_collector_Params.number_of_detach);
+
+    QCRIL_LOG_INFO(" bearer_type value after %d", qmi_ril_nw_data_collector_Params.bearer_type);
+    QCRIL_LOG_INFO(" qci value after %d", qmi_ril_nw_data_collector_Params.qci);
+    QCRIL_LOG_INFO(" ambr_ul value after %d", qmi_ril_nw_data_collector_Params.ambr_ul);
+    QCRIL_LOG_INFO(" ambr_dl value after %d", qmi_ril_nw_data_collector_Params.ambr_dl);
+    QCRIL_LOG_INFO(" gbr_ul value after %d", qmi_ril_nw_data_collector_Params.gbr_ul);
+    QCRIL_LOG_INFO(" gbr_dl value after %d", qmi_ril_nw_data_collector_Params.gbr_dl);
+    QCRIL_LOG_INFO(" bler value after %d", qmi_ril_nw_data_collector_Params.bler);
+    QCRIL_LOG_INFO(" rstd0 value after %d", qmi_ril_nw_data_collector_Params.rstd0);
+    QCRIL_LOG_INFO(" rstd1 value after %d", qmi_ril_nw_data_collector_Params.rstd1);
+    QCRIL_LOG_INFO(" rstd2 value after %d", qmi_ril_nw_data_collector_Params.rstd2);
+
    /* Send the response to UI */
    qcril_qmi_nas_send_request_reponse(instance_id, params_ptr->t, params_ptr->event_id,
                                         RIL_E_SUCCESS, (void *)&qmi_ril_nw_data_collector_Params, sizeof(qmi_ril_nw_data_collector_Params));
diff --git a/qcril/qcril_qmi/qcril_qmi_voice.c b/qcril/qcril_qmi/qcril_qmi_voice.c
index 795ac8a..8993b49 100755
--- a/qcril/qcril_qmi/qcril_qmi_voice.c
+++ b/qcril/qcril_qmi/qcril_qmi_voice.c
@@ -155,6 +155,11 @@ dtmf_digits: 64 bytes */
 #define QMI_RIL_WPS_PROP                        "persist.radio.is_wps_enabled"
 #define QMI_RIL_WPS_PROP_LENGTH                 (4)
 
+#define PROP_DATA_COLLECTOR_NUM_MO_CALL "persist.radio.dc.nummocall"
+#define PROP_DATA_COLLECTOR_NUM_MT_CALL "persist.radio.dc.nummtcall"
+#define PROP_DATA_COLLECTOR_NUM_DIAL_FAIL "persist.radio.dc.numofdialfail"
+#define PROP_DATA_COLLECTOR_NUM_CALL_DROP "persist.radio.dc.numofcalldrop"
+
 /*===========================================================================
 
                     QMI VOICE GLOBALS
@@ -3821,7 +3826,7 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
   char  callID[5] = "\0";
   int rc = 0;
 
-  uint8_t dataCollectorEvents = 0;
+  uint8_t dataCollectorEvents = -1;
 
   int32_t iter_media_id = INVALID_MEDIA_ID;
 
@@ -4248,6 +4253,10 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
                       iter_media_id,
                       TRUE,
                       QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING );
+              dataCollectorEvents = DATA_COLLECTOR_EVENT_INCOMING_CALL;
+              incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_MT_CALL);
+              QCRIL_LOG_INFO("Indicate data collector indication id - %d", dataCollectorEvents);
+              qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
             }
             else
             { // what we got?
@@ -4580,6 +4589,7 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
             QCRIL_LOG_ESSENTIAL("call state CONVERSATION for conn id %d", iter_call_info->call_id);
             ril_call_state_valid = TRUE;
             ril_call_state = RIL_CALL_ACTIVE;
+            dataCollectorEvents = 0;
 
             call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( iter_call_info->call_id );
             if ( ( NULL == call_info_entry ) && ( TRUE == srvcc_parent_call_info_valid ) && ( NULL != srvcc_parent_call_info ) )
@@ -4650,6 +4660,15 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
                 }
               }
 
+              if ( !iter_call_info->is_mpty && (call_info_entry->voice_scv_info.call_state != CALL_STATE_HOLD_V02)
+                      && (call_info_entry->voice_scv_info.call_state != CALL_STATE_CONVERSATION_V02) ) {
+                  //Fresh call connected.
+                  dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_ESTABLISHED;
+              } else {
+                  //Existing call hold/resume or call merged
+                  dataCollectorEvents = 0;
+              }
+
               switch ( call_info_entry->voice_scv_info.call_state ) // check previous state
               {
                 case CALL_STATE_ORIGINATING_V02:
@@ -4811,9 +4830,10 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
             }
 
             qcril_qmi_voice_set_cdma_call_id_if_applicable_vcl(iter_call_info);
-            dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_ESTABLISHED;
-            QCRIL_LOG_INFO("initiate data collector indication id - %d", dataCollectorEvents);
-            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+            if (dataCollectorEvents > 0) {
+                QCRIL_LOG_INFO("initiate data collector indication id - %d", dataCollectorEvents);
+                qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+            }
 
             break; // end of case CALL_STATE_CONVERSATION_V02
 
@@ -4838,7 +4858,6 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
                 }
               }
             }
-
             // Now, classify the failure cause depending on previous state
             if(call_info_entry)
             {
@@ -4853,6 +4872,7 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
 
                 default:
                      QCRIL_LOG_ESSENTIAL("This one is either a MT call or, a connected call");
+                     dataCollectorEvents = 0;
                     break;
               }
             }
@@ -5020,8 +5040,11 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
                 if (call_info_entry->lcf_valid && call_info_entry->lcf == CALL_FAIL_NORMAL) {
                     dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_DISCONNECT;
                 } else {
+                    incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_CALL_DROP);
                     dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_DROP;
                 }
+            } else {
+                incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_DIAL_FAIL);
             }
             if(call_info_entry->lcf_valid) {
                 QCRIL_LOG_ESSENTIAL("Initiate data collector last failed cause - %d", call_info_entry->lcf);
@@ -5217,9 +5240,6 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
             }
 
             qcril_qmi_voice_set_cdma_call_id_if_applicable_vcl(iter_call_info);
-            dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_TRIGGERED;
-            QCRIL_LOG_INFO("Indicate data collector indication id - %d", dataCollectorEvents);
-            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
 
             break; // end of case CALL_STATE_ORIGINATING_V02
 
@@ -5392,6 +5412,11 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
                       iter_media_id,
                       TRUE,
                       QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING );
+
+              dataCollectorEvents = DATA_COLLECTOR_EVENT_INCOMING_CALL;
+              incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_MT_CALL);
+              QCRIL_LOG_INFO("Indicate data collector indication id - %d", dataCollectorEvents);
+              qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
             }
             else
             {
@@ -7990,6 +8015,10 @@ void qcril_qmi_voice_dial_call_resp_hdlr
           call_info_entry->media_id = INVALID_MEDIA_ID;
         }
         QCRIL_LOG_INFO( "call qmi id recorded %d", (int)call_info_entry->qmi_call_id );
+        int dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_TRIGGERED;
+        incrementPersistStorage(PROP_DATA_COLLECTOR_NUM_MO_CALL);
+        QCRIL_LOG_INFO("Indicate data collector indication id - %d", dataCollectorEvents);
+        qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
         break;
 
       default:
diff --git a/qcril/qcril_qmi/qcrili.h b/qcril/qcril_qmi/qcrili.h
index 6c1b7cc..fe1a361 100755
--- a/qcril/qcril_qmi/qcrili.h
+++ b/qcril/qcril_qmi/qcrili.h
@@ -1076,7 +1076,7 @@ typedef struct {
 } RIL_SubProvStatus;
 
 typedef enum  {
-    DATA_COLLECTOR_EVENT_CALL_TRIGGERED,
+    DATA_COLLECTOR_EVENT_CALL_TRIGGERED = 1,
     DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED,
     DATA_COLLECTOR_EVENT_CALL_ESTABLISHED,
     DATA_COLLECTOR_EVENT_CALL_DISCONNECT,
@@ -1101,9 +1101,52 @@ typedef enum  {
     DATA_COLLECTOR_EVENT_CELL_RESELECTION,
     DATA_COLLECTOR_EVENT_RACH_FAILURE,
     DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL,
-    DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL
+    DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL,
+    DATA_COLLECTOR_EVENT_INCOMING_CALL
 }Data_Collector_Event_e_type;
 
+typedef struct
+{
+    int32_t pci;
+    int32_t rsrp;
+    int32_t rsrq;
+    int32_t sinr;
+    int32_t activeband;
+    uint32_t lte_earfcn;
+    int32_t  srv_status;
+    int32_t timing_advance;
+    int32_t Roaming_Indicator;
+    int32_t sip_reg_status;
+    int32_t tac;
+    int32_t cqi;
+    int32_t rankIndicator;
+    int32_t attach_fail_cause;
+    int32_t tac_fail_cause;
+    int32_t eps_bearer_id;
+    int32_t rrc_conn_cause;
+    int32_t rrc_rel_cause;
+    int32_t prach_tx_power;
+    int32_t bler;
+    int32_t tx_power;
+    int32_t rstd0;
+    int32_t rstd1;
+    int32_t rstd2;
+    int32_t rtp_packet_loss;
+    int32_t total_rtp_loss;
+    int32_t bearer_id;
+    int32_t bearer_type;
+    int32_t qci;
+    int32_t ambr_ul;
+    int32_t ambr_dl;
+    int32_t gbr_ul;
+    int32_t gbr_dl;
+    int32_t number_of_attach;
+    int32_t number_of_attach_fail;
+    int32_t number_of_detach;
+    int32_t cells[12][3]; //Twelve set of neighbor cells each cell contains {pci, rsrp, rsrq}
+    int32_t number_of_cells;
+    int32_t mute[4]; //Array of numbers for extra short, short, medium and long muting events Ex: {5,2,4,0}
+}qmi_ril_nw_data_collector_Param;
 
 #ifndef RIL_REQUEST_SET_RADIO_CAPABILITY
 #define RIL_REQUEST_SET_RADIO_CAPABILITY 10117
-- 
1.9.1

