From f07e8c2e927a6201c12cbc8c1ecff95dd864f09f Mon Sep 17 00:00:00 2001
From: Ranjit Mishra <ranjit.mishra@borqs.com>
Date: Tue, 1 Aug 2017 16:27:22 +0530
Subject: [PATCH] M0062427 : Implemented RJIL Data Collector

Change-Id: Iae1830eb145f3232e1a52087c2354a01714526c0
---
 b2g_telephony/Android.mk                     |   1 +
 b2g_telephony/NetworkDataCollector.cpp       | 724 +++++++++++++++++++++++++++
 b2g_telephony/RIL.cpp                        |  16 +-
 b2g_telephony/RILHelper.cpp                  |  37 ++
 b2g_telephony/include/NetworkDataCollector.h | 124 +++++
 b2g_telephony/include/RIL.h                  |  41 ++
 b2g_telephony/include/RILHelper.h            |   1 +
 b2g_telephony/include/RIL_unsol_commands.h   |   2 +-
 qcril/qcril_qmi/qcril.c                      |   3 +
 qcril/qcril_qmi/qcril_log.c                  |   6 +
 qcril/qcril_qmi/qcril_qmi_nas.c              | 263 +++++++++-
 qcril/qcril_qmi/qcril_qmi_nas.h              |  10 +
 qcril/qcril_qmi/qcril_qmi_voice.c            |  24 +
 qcril/qcril_qmi/qcrili.h                     |  36 ++
 14 files changed, 1283 insertions(+), 5 deletions(-)
 create mode 100644 b2g_telephony/NetworkDataCollector.cpp
 create mode 100644 b2g_telephony/include/NetworkDataCollector.h

diff --git a/b2g_telephony/Android.mk b/b2g_telephony/Android.mk
index 141c1c9..094d5e9 100755
--- a/b2g_telephony/Android.mk
+++ b/b2g_telephony/Android.mk
@@ -123,6 +123,7 @@ LOCAL_SRC_FILES := \
 	SupplementaryServices.cpp \
 	SystemMessengerHelper.cpp \
 	TelephonyLauncher.cpp \
+	NetworkDataCollector.cpp \
 	TonePlayer.cpp \
 	TtyManager.cpp \
 	WiredHeadsetManager.cpp \
diff --git a/b2g_telephony/NetworkDataCollector.cpp b/b2g_telephony/NetworkDataCollector.cpp
new file mode 100644
index 0000000..ab436d9
--- /dev/null
+++ b/b2g_telephony/NetworkDataCollector.cpp
@@ -0,0 +1,724 @@
+/*
+ * Copyright (c) 2012-2015 Qualcomm Technologies, Inc.  All Rights Reserved.
+ * Qualcomm Technologies Proprietary and Confidential.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "NetworkDataCollector.h"
+
+/* Logging related */
+#undef LOG_TAG
+#define LOG_TAG "NW_DATA_COLLECTOR"
+#include "LogUtils.h"
+#include <utils/SystemClock.h>
+#include <iostream>
+#include <fstream>
+#include <sys/un.h>
+#include "Conversion.h"
+#include <sstream>
+#include <iomanip>
+
+
+
+
+NS_NAMED_LITERAL_CSTRING(RILD_OEM_SOCKET_NAME, "qmux_radio/rild_oem");
+
+#define NETWORK_DATA_COLLECTOR_RETRY_SECONDS 60
+// Max time to wait for a response to an OEM hook request
+#define MAX_OEM_HOOK_REQ_TIME_MSEC 10 * 1000
+
+#define NETWORK_PARAMS_LOG_FILE       "/data/data/media/network_parameters.txt"
+
+NS_NAMED_LITERAL_CSTRING(DATA_COLLECTOR_SERVER_SOCKET_NAME, "/system/kaios/metricsd_socket");
+
+//#define SERVER_DATA_COLLECTOR_SOCKET_NAME  "/system/kaios/metricsd_socket"
+// Amount of time to sleep while waiting for a response to allow yielding of
+// CPU to other threads
+#define SYNC_RSP_SLEEP_USEC 50 * 1000
+
+#define MAX_COMMAND_BYTES (8 * 1024)
+
+#define MAX_RESPONSE_BYTES 1024
+
+#define INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET  "{ \"source\": \"ril_metrics\" }"
+
+#define DATA_COLLECTOR_UNSOL_OEM_HOOK_RAW_IND  525343
+
+#define LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND 525344
+
+#define QCRIL_QMI_VOICE_MAX_FAIL_CAUSE_STR_LEN     256
+
+
+typedef struct
+{
+    uint8_t frameType;
+    uint32_t payloadLength;
+    int8_t* payload;
+}data_collector_frame;
+
+/*============= Implementation of Class DataCollectorSocket =============*/
+
+/**
+ *
+ */
+DataCollectorSocket::DataCollectorSocket(NetworkDataCollector* NWDataCollector, const nsACString& name, bool useRilApi,
+    void (*dcCallback)(void*))
+    : mFd(-1),
+      mUseRilApi(useRilApi),
+      mName(name) {
+    QLOGE("NetworkDataCollector : DataCollectorSocket initialize");
+    mReceiver = NWDataCollector;
+    RefPtr<nsRunnable> runnable = NS_NewRunnableMethod(mReceiver,
+                                                                  &NetworkDataCollector::Run);
+
+    // Start the RilReceiver thread for this socket
+    NS_NewThread(getter_AddRefs(mThread), runnable);
+}
+
+/*============= Implementation of Class RilSocket =============*/
+
+/**
+ *
+ */
+DataCollectorSocket::~DataCollectorSocket() {
+  Close();
+}
+
+/**
+ * Get the name of the socket (i.e. "rild1")
+ * Returns the name as a basic C string instead of nsCString since it is always
+ * fed into functions that require a char * input.
+ */
+const char* DataCollectorSocket::GetName() {
+    return mName.get();
+};
+
+void DataCollectorSocket::Shutdown() {
+    mReceiver->Shutdown();
+}
+
+/**
+ * Closes a socket
+ */
+void DataCollectorSocket::Close() {
+    if (mFd >= 0) {
+    close(mFd);
+    }
+    mFd = -1;
+}
+
+/**
+ *
+ */
+void DataCollectorSocket::OnDisconnect(bool isShuttingDown) {
+  Close();
+//  DispatchRunnable(mDisconnectRunnable, isShuttingDown);
+}
+
+
+/*============= Implementation of Class NetworkDataCollector =============*/
+
+/**
+ *
+ */
+NetworkDataCollector::NetworkDataCollector(RIL* ril) :ImsResponseHandler(ril), mRil(ril),
+                               mSyncMutex(PTHREAD_MUTEX_INITIALIZER), mResult(RIL_E_SUCCESS), mReceivedResponse(false),mServerReady(false),mShuttingDown(false) {
+    mSeqNumber = 1; // count starts from 1
+    mSenderEvent = DATA_COLLECTOR_EVENT_CALL_TRIGGERED;
+    mRilLastFailCause = CALL_FAIL_NORMAL_UNSPECIFIED;
+    mRil->RegisterForUnsol(RIL_UNSOL_OEM_HOOK_RAW, this);
+}
+
+NetworkDataCollector::~NetworkDataCollector() {
+      mRil->UnRegisterForUnsol(RIL_UNSOL_OEM_HOOK_RAW, this);
+}
+ void NetworkDataCollector::Initialize() {
+    nsCString socketName;
+    socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
+    QLOGE("NetworkDataCollector  initialize");
+
+    mSocket = new DataCollectorSocket(this, socketName, true);
+ }
+
+ void NetworkDataCollector::Shutdown() {
+   mShuttingDown = true;
+ }
+
+ void NetworkDataCollector::HandleRilUnSolicitedResponse(RILResult& result) {
+     int messageID = result.mMessageID;
+     QLOGE("Received unsolicited response %s", RequestToString(messageID));
+
+     switch (messageID) {
+        case RIL_UNSOL_OEM_HOOK_RAW: {
+           uint8_t *p = nullptr;
+           p = (uint8_t* ) result.data;
+          QLOGE("HandleUnSolicitedResponse, data len = %d",result.datalen);
+          int index = 8; //starting index of event id and size.
+          if(result.datalen > 16) {
+             int event = (uint32_t)((p[index+3])  << 24 | (p[index+2]) << 16 | (p[index+1]) << 8 |(p[index]));
+             if(event == DATA_COLLECTOR_UNSOL_OEM_HOOK_RAW_IND) {
+                 int event_size = (uint32_t)((p[index+7])  << 24 | (p[index+6]) << 16 | (p[index+5]) << 8 |(p[index+4]));
+                 QLOGE("HandleUnSolicitedResponse, data collector event length = %d",event_size);
+                 if(event_size) {
+                     int eventType =  p[index+8];
+                     HandleDataCollectorEvent(eventType);
+                 }
+            }
+            if(event == LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND) {
+                 int event_size = (uint32_t)((p[index+7])  << 24 | (p[index+6]) << 16 | (p[index+5]) << 8 |(p[index+4]));
+                 QLOGE("HandleUnSolicitedResponse, last fail cause event length = %d",event_size);
+                 if(event_size) {
+                     mRilLastFailCause =  (uint32_t)((p[index+11])  << 24 | (p[index+10]) << 16 | (p[index+9]) << 8 |(p[index+8]));
+                     QLOGE("HandleUnSolicitedResponse, last fail cause  = %d",mRilLastFailCause);
+                     // RJIL do not support error higher value  then CALL_FAIL_DIAL_MODIFIED_TO_DIAL(246),
+                     //because those errors are for cdma network specific and JIO network does not expect that..
+                     if(mRilLastFailCause > CALL_FAIL_DIAL_MODIFIED_TO_DIAL) {
+                        mRilLastFailCause = CALL_FAIL_NORMAL_UNSPECIFIED;
+                     }
+                }
+            }
+          }
+       }
+       break;
+       default:
+          QLOGE("%s: unexpected request %s", __FUNCTION__, RequestToString(messageID));
+       break;
+      }
+ }
+
+void  NetworkDataCollector::SendCallTriggeredDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_TRIGGERED);
+}
+
+ void  NetworkDataCollector::SendCallAttemptFailedDataToServer() {
+     QLOGE("%s new thread began", __FUNCTION__);
+     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED);
+ }
+
+ void  NetworkDataCollector::SendCallEstablishedDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ESTABLISHED);
+}
+
+ void  NetworkDataCollector::SendCallDisconnectDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DISCONNECT);
+}
+
+ void  NetworkDataCollector::SendCallDropDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DROP);
+}
+
+ void  NetworkDataCollector::SendTacUpdateDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_TAC_UPDATE);
+}
+
+
+ void NetworkDataCollector::HandleDataCollectorEvent( int eventType) {
+    bool isValidType = true;
+    RefPtr<nsRunnable> runnable = nullptr;
+    QLOGE("%s event type = %d", __FUNCTION__,eventType);
+    switch(eventType) {
+        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallTriggeredDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallAttemptFailedDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallEstablishedDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDisconnectDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_DROP:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDropDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_MUTING:
+        case DATA_COLLECTOR_EVENT_SMS_SENT:
+        case DATA_COLLECTOR_EVENT_SMS_RECIVED:
+        case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
+        case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
+        case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
+        case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
+        case DATA_COLLECTOR_EVENT_IN_SERVICE:
+        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+            isValidType = false;
+            break;
+        case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendTacUpdateDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
+        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+        case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+        case DATA_COLLECTOR_EVENT_RACH_FAILURE:
+        case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
+        case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
+        default:
+            isValidType = false;
+            break;
+
+        }
+
+      // Start the new  thread for this operation
+      if(isValidType)
+            NS_NewThread(getter_AddRefs(mDataCollectorSenderThread), runnable);
+    }
+
+ /**
+  * Handles the solicited requests from RIL
+  *
+  * @param aResult The response data from the OEM hook request
+  */
+ void NetworkDataCollector::HandleRilSolicitedResponse(RILResult& aResult) {
+    int messageID = aResult.mMessageID;
+    QLOGD("HandleSolicitedResponse %s", RequestToString(messageID));
+
+    if (messageID != RIL_REQUEST_OEM_HOOK_RAW) {
+       QLOGE("NetworkDataCollector Message %s not supported", RequestToString(messageID));
+       return;
+    }
+    qmi_ril_nw_data_collector_Params *nwParams = (qmi_ril_nw_data_collector_Params *)aResult.data;
+
+   mResponse.Clear();
+   mResult = aResult.mError;
+
+   // Even for success case, result data can be null
+   if (aResult.data) {
+     mResponse.AppendElements((uint8_t*) aResult.data, aResult.datalen);
+     QLOGD("received data length %d", aResult.datalen);
+   }
+
+     mReceivedResponse = true;
+ }
+
+ /**
+ * Send an OEM hook request to RIL
+ *
+ * @param aClientId Indicate the RIL client this request is made for
+ * @param aRr The OEM hook request object
+ * @param aAsyncRequest Indicate if the requester expects the response to be
+ * returned as synchronous or asynchronous. If synchronous is expected, the
+ * following params are to be filled with the response data.
+ * @param aResult The RIL_Errno result of the OEM hook request
+ * @param aResponse The response data to the OEM hook request
+ * @param aRespLength Length of aResponse array
+ * @return The nsresult of the request
+ */
+nsresult NetworkDataCollector::SendRequest(uint32_t aClientId, OemRequest* aRr,
+    bool aAsyncRequest, uint32_t* aResult, const uint8_t** aResponse,  uint32_t* aRespLength) {
+  QRLOGD("[SUB%d] [%04d]> %s", mRil->GetClientId(), aRr->mSerial,  RequestToString(aRr->mRequest));
+
+  // Only one synchronous request can be sent at a time
+  if (!aAsyncRequest) {
+    pthread_mutex_lock(&mSyncMutex);
+  }
+
+  mRil->Send(aRr);
+
+  if (aAsyncRequest) {
+    return NS_OK;
+  } else {
+    nsresult result = WaitForResponse(aResult, aResponse, aRespLength);
+    pthread_mutex_unlock(&mSyncMutex);
+    return result;
+  }
+}
+
+/**
+ * Blocks the current thread until a response to an OEM hook request is
+ * received or MAX_OEM_HOOK_REQ_TIME_MSEC is reached
+ *
+ * @param aResult The result (success/error) of the request
+ * @param aResponse The response data to the OEM hook request
+ * @param aRespLength Length of aResponse array
+ * @return The nsresult of the request
+ */
+nsresult NetworkDataCollector::WaitForResponse(uint32_t* aResult,
+    const uint8_t** aResponse, uint32_t* aRespLength) {
+    // Wait for the response to an OEM hook request until max waiting time
+    int64_t endTime = android::elapsedRealtime() + MAX_OEM_HOOK_REQ_TIME_MSEC;
+    QLOGD(" NetworkDataCollector:WaitForResponse begin loop");
+    while (android::elapsedRealtime() < endTime) {
+        if (mReceivedResponse) {
+            break;
+        }
+        usleep(SYNC_RSP_SLEEP_USEC);
+    }
+    QLOGD(" NetworkDataCollector:WaitForResponse loop finished");
+
+    // There should be a response by now
+    if (!mReceivedResponse) {
+        *aResult = RIL_E_GENERIC_FAILURE;
+        return NS_ERROR_FAILURE;
+    }
+
+    *aResult = mResult;
+    mReceivedResponse = false;
+
+    if(mResponse.Length() > 0) {
+        // Caller is responsible for freeing the response data
+        uint8_t* response = new uint8_t[mResponse.Length()];
+        memcpy(response, mResponse.Elements(), mResponse.Length());
+        *aResponse = response;
+        *aRespLength = mResponse.Length();
+    } else {
+        QLOGE(" NetworkDataCollector: data length is zero");
+        *aRespLength = 0;
+    }
+
+  return NS_OK;
+}
+
+std::string NetworkDataCollector::tohex(const  std::string& s, bool upper)
+{
+    std::ostringstream ret;
+
+    unsigned int c;
+    for (std::string::size_type i = 0; i < s.length(); ++i)
+    {
+        c = (unsigned int)(unsigned char)s[i];
+        ret << std::hex << std::setfill('0') << std::setw(2) << (upper ? std::uppercase : std::nouppercase) << c;
+    }
+    return ret.str();
+}
+
+const char* NetworkDataCollector::getDataCollectorEventCode(DataCollectorEventCodes eventType) {
+    switch(eventType) {
+        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+            return "NE1";
+        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+            return "NE2";
+        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
+            return "NE3";
+        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
+            return "NE4";
+        case DATA_COLLECTOR_EVENT_CALL_DROP:
+            return "NE5";
+        case DATA_COLLECTOR_EVENT_CALL_MUTING:
+            return "NE6";
+        case DATA_COLLECTOR_EVENT_SMS_SENT:
+            return "NE7";
+        case DATA_COLLECTOR_EVENT_SMS_RECIVED:
+            return "NE8";
+        case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
+            return "NE9";
+        case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
+            return "NE10";
+        case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
+            return "NE11";
+        case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
+            return "NE12";
+        case DATA_COLLECTOR_EVENT_IN_SERVICE:
+            return "NE13";
+        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+            return "NE14";
+        case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+            return "NE15";
+        case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
+            return "NE16";
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
+            return "NE17";
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+            return "NE18";
+        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
+            return "NE19";
+        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+            return "NE20";
+        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+            return "NE21";
+        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+            return "NE22";
+        case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+            return "NE23";
+        case DATA_COLLECTOR_EVENT_RACH_FAILURE:
+            return "NE24";
+        case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
+            return "NE25";
+        case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
+            return "NE26";
+
+       default:
+        QLOGD("getDataCollectorEventCode : unexpected event code");
+            return " "; //empty string , this is not expected.
+
+    }
+}
+
+void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event) {
+    uint8_t frame[MAX_RESPONSE_BYTES];
+    bzero(frame,MAX_RESPONSE_BYTES);
+    QLOGD("NetworkDataCollector  sentNWDataToServer");
+
+    if(mSeqNumber >= 0xFFFFFFFFFFFFFFFF)
+        mSeqNumber = 1;
+
+    std::time_t currentTime = std::time(NULL);
+
+    char jsonPayload[MAX_RESPONSE_BYTES];
+    bzero(jsonPayload,MAX_RESPONSE_BYTES);
+
+    /*As per network_access_service_v01.h, QC's LTE band starts from 120.
+       Set default band as 3, if wrong band is reported. So that at least other parameters gets reported,
+       otherwise metircs server will disconnect the socket connection. This logic needs to be removed once RJIL updated their requirement*/
+    int activeband = (pNetworkParams->activeband > 119) ? (pNetworkParams->activeband-119):3;
+
+    // Note:- as per 80-nv304-6_b_qmi_network_access_service_spec , RSRP range: -44 to -140, RSRQ range : -3 to -20, LTE SNR level scaled integer in units of 0.1dB e.g. 24.6 has a value of 246.
+    sprintf (jsonPayload,"[{ \"seq_number\": %llu, \"timestamp\": %ld, \"payload\": { \"Name\":\"%s\",\"RI1\":%d,\"RI2\":%d,\"RI3\":%d,\"RI6\":%d,\"RI7\":%d,\"RI8\":%s,\"RI13\": %d,\"VI2\": %d,\"NI1\":%s,\"VI1\": \"%s\"}}]",
+                            mSeqNumber,currentTime,getDataCollectorEventCode(event),(140+pNetworkParams->rsrp),(20+pNetworkParams->rsrq),pNetworkParams->sinr/10, activeband, pNetworkParams->lte_earfcn,
+                            pNetworkParams->srv_status?"true":"false",pNetworkParams->timing_advance>0?pNetworkParams->timing_advance:0,mRilLastFailCause,pNetworkParams->Roaming_Indicator?"true":"false",(pNetworkParams->sip_reg_status==1)?"REGISTERED":"NOT REGISTER");
+
+   QLOGD(" payload = %s",jsonPayload);
+
+    mSeqNumber++;//increase it for next message
+    int length = strlen(jsonPayload);
+    QLOGD(" payload length = %d",length);
+    uint32_t nwByteOrderlength = htonl(length);
+    char numberStr[4];
+    memcpy(numberStr, &nwByteOrderlength, 4);
+
+    frame[0] = 0x01; //  this is fixed value
+    frame[1]=numberStr[0];
+    frame[2]=numberStr[1];
+    frame[3]=numberStr[2];
+    frame[4]=numberStr[3];
+
+    char stringhexdata[MAX_RESPONSE_BYTES/2];
+    std::memcpy(stringhexdata, tohex(jsonPayload).c_str(), 2*length);
+    uint8_t* body = HexStringToBytes(stringhexdata,length);
+    std::memcpy(frame+5,body,length);
+
+    if(mSocket && mSocket->mFd) {
+        int n = write(mSocket->mFd,frame,5+length); // 1 for type, 4 for length - total 5 bytes
+        if (n < 0) {
+            QRLOGE("ERROR writing to socket");
+        }
+
+    } else {
+         QRLOGE("ERROR not connected to server socket");
+    }
+
+    if(body != NULL)
+        delete [] body;
+
+}
+
+NS_IMETHODIMP NetworkDataCollector::sendHandShakeMsgToServer() {
+    uint8_t buffer[MAX_RESPONSE_BYTES];
+    QLOGD("NetworkDataCollector  sendHandShakeMsgToServer");
+    sleep(10);//Sleep for few seconds before sending data, suggested by kaios team.
+    bzero(buffer,MAX_RESPONSE_BYTES);
+    int length = strlen(INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET);
+    uint32_t nwByteOrderlength = htonl(length);
+    char numberStr[4];
+    memcpy(numberStr, &nwByteOrderlength, 4);
+    buffer[0] = 0x01; //  this is fixed value
+    buffer[1]=numberStr[0];
+    buffer[2]=numberStr[1];
+    buffer[3]=numberStr[2];
+    buffer[4]=numberStr[3];
+    std::string str1 = INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET;
+    char stringhexdata[MAX_RESPONSE_BYTES/2];
+    std::memcpy(stringhexdata, tohex(str1).c_str(), 2*length);
+    uint8_t* body = HexStringToBytes(stringhexdata,length);
+    std::memcpy(buffer+5,body,length);
+    if(mSocket && mSocket->mFd) {
+        int n = write(mSocket->mFd,buffer,5+length); // 1 for type, 4 for length -- total 5 bytes
+        if (n < 0) {
+            QRLOGE("ERROR writing to socket");
+        }
+    } else {
+        QRLOGE("ERROR no socket fd to server socket");
+    }
+
+    if(body != NULL)
+        delete [] body;
+
+    return NS_OK;
+ }
+
+
+
+NS_IMETHODIMP NetworkDataCollector::Run() {
+    struct pollfd poll_rild_fd;
+    int rc = 0;
+    int ret = 0;
+    int retryCount = 0;
+    nsCString socketName;
+    nsresult result = NS_ERROR_FAILURE;
+    struct sockaddr_un serveraddr;
+    unsigned char readBuffer[MAX_RESPONSE_BYTES];
+
+    // server socket name
+    socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
+
+    QLOGD(" NetworkDataCollector:run  begin");
+    if (NS_IsMainThread()) {
+        QLOGE("Error: This will deadlock if called from the main thread");
+        return NS_ERROR_UNEXPECTED;
+    }
+
+    for (;;) {
+
+         // create the client socket and poll on it.
+        do {
+            // Always sleep first.  At boot the rild and b2g process are launched
+            // concurrently, and rild contains a race condition whereby it creates its
+            // socket before it's fully prepared to handle all the requests and network is registered.
+            sleep(NETWORK_DATA_COLLECTOR_RETRY_SECONDS);
+
+             if(mShuttingDown) {
+                QLOGE(" NetworkDataCollector: server connection is not ready or shuting down, so return");
+                return result;
+             }
+            // Connect to server socket
+            QLOGD("Connecting to socket %s", mSocket->GetName());
+            if ((mSocket->mFd = socket(AF_UNIX,SOCK_STREAM,0)) >= 0)
+           {
+                memset(&serveraddr, 0, sizeof(serveraddr));
+                serveraddr.sun_family = AF_UNIX;
+                strcpy(serveraddr.sun_path,"/system/kaios/metricsd_socket");
+                QRLOGD(" NetworkDataCollector: socket fd=%d, sockaddress length= %d",mSocket->mFd,sizeof(serveraddr));
+                if( connect(mSocket->mFd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0 )
+                {
+                   QRLOGE("Connect socket failed, errno=%s",strerror(errno));
+                   // close socket so that we can create it again in loop
+                    mSocket->OnDisconnect(mRil->mIsShuttingDown);
+                } else {
+                 QRLOGD("Connect socket successful");
+                    break;
+                }
+            }
+
+            // Retry again if the socket fails to connect
+            if (retryCount == 8) {
+              QRLOGE("Couldn't connect to  '%s ' socket after %d times, "
+                      "continuing to retry silently", mSocket->GetName(), retryCount);
+            } else if (retryCount > 0 && retryCount < 8) {
+              QRLOGD("Couldn't connect to '%s' socket; retrying after timeout, errno=%s", mSocket->GetName(),strerror(errno));
+            }
+            retryCount++;
+        }while(true);
+
+       QRLOGD("Connected to socket %s", mSocket->GetName());
+       retryCount = 0;
+       if(1) {
+            // Create a thread for initial handshaking message.
+            RefPtr<nsRunnable> runnable = NS_NewRunnableMethod(this,
+                                                                  &NetworkDataCollector::sendHandShakeMsgToServer);
+            // Start the new  thread for this operation
+            NS_NewThread(getter_AddRefs(mThread), runnable);
+        }
+        // Poll the server data collector socket to see if there is data to be read
+        poll_rild_fd.fd = mSocket->mFd;
+        poll_rild_fd.events = POLLIN;
+        poll_rild_fd.revents = 0;
+
+        // Read while the socket is connected to data collector server
+        while (1) {
+            if (mShuttingDown) {
+                QRLOGW("Data collector server is shutting down; exiting NetworkDataCollector thread for socket %s",
+                         mSocket->GetName());
+                return result;
+            }
+            // Poll socket for data availability
+            rc = poll(&poll_rild_fd, 1, -1);
+
+            // If there is an error in polling
+            if (rc < 0) {
+                QRLOGE("Error in polling %s; bailing out",  mSocket->GetName());
+                break;
+            }
+
+            if (poll_rild_fd.revents == POLLERR) {
+                QRLOGE("Closing NetworkDataCollector socket %s: POLLERR", mSocket->GetName());
+                break;
+            }
+
+            // Any server data to read?
+            if (poll_rild_fd.revents != POLLIN) {
+                QRLOGD("Error! revents= %d, not POLLIN revents , rc = %d",poll_rild_fd.revents,rc);
+                break;//continue is not fiing the issue.
+            }
+
+            // Read data from the socket
+            int readResult = read(mSocket->mFd, readBuffer, MAX_RESPONSE_BYTES);
+            if((readResult < 0 )) {
+                 /* looks like socket got disconneccted at far end. */
+                 QLOGE("looks like server socket got disconneccted/closed  errno=%s",strerror(errno));
+                  break;
+             } else {
+                  // handle the data collector server response.
+                 QLOGE("got response from server socket ret=%d",readResult);
+                 mServerReady = true; // need to set on first handshake message response.
+             }
+        }
+
+        // Clean up
+        QRLOGD("Closing client socket. FD= %d", mSocket->mFd);
+        mSocket->OnDisconnect(mRil->mIsShuttingDown);
+        mServerReady = false;
+        mSeqNumber = 1;
+
+        }
+    }
+
+    void  NetworkDataCollector::HandleImsSolicitedResponse(RILResult& result) {
+        QRLOGD("HandleImsSolicitedResponse");
+        }
+    void  NetworkDataCollector::HandleImsUnSolicitedResponse(RILResult& result) {
+        QRLOGD("HandleImsUnSolicitedResponse");
+        }
+
+    void  NetworkDataCollector::SendNetworkDataToServer(DataCollectorEventCodes event) {
+    uint32_t aRespLength = 0;
+    const uint8_t **aResponse = new const uint8_t*;
+    uint32_t aResult = 0;
+    uint32_t aReqLength = 4;
+
+    QLOGD(" SendNetworkDataToServer  event = %d",event);
+
+    if(!mServerReady ||  mShuttingDown) {
+        QLOGE(" NetworkDataCollector: server connection is not ready or shuting down");
+        return;
+    }
+
+    QLOGD(" NetworkDataCollector: Extracting nework data on socket %s",  mRil->mOemSocket->GetName());
+    OemRequest* rr = OemRequest::Obtain(QRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS, this);
+    SendRequest(mRil->GetClientId(), rr, false, &aResult, aResponse, &aRespLength);
+
+    if(aRespLength > 0) {
+        qmi_ril_nw_data_collector_Params *nwParams = (qmi_ril_nw_data_collector_Params *) *aResponse;
+        //write data to server socket.
+        sendNWDataToServer(nwParams,event);
+    }
+    if((aResponse != nullptr) && (*aResponse != nullptr))
+          delete [](*aResponse);
+}
+
diff --git a/b2g_telephony/RIL.cpp b/b2g_telephony/RIL.cpp
index 8d58ff2..b6c341f 100755
--- a/b2g_telephony/RIL.cpp
+++ b/b2g_telephony/RIL.cpp
@@ -34,6 +34,8 @@
 #include "IccManager.h"
 #include "PhoneNumberUtils.h"
 #include "PhoneUtils.h"
+#include <utils/SystemClock.h>
+#include "NetworkDataCollector.h"
 
 /* Logging related */
 #undef LOG_TAG
@@ -47,7 +49,7 @@ NS_NAMED_LITERAL_CSTRING(IMS_SOCKET_NAME, "qmux_radio/rild_ims");
 
 #define SOCKET_OPEN_RETRY_SECONDS 4
 #define MAX_COMMAND_BYTES (8 * 1024)
-
+#define PROP_DATA_COLLECTOR_ENABLED "persist.radio.dc.enabled"
 /* Global declarations */
 pthread_mutex_t RilRequest::sSerialMutex = PTHREAD_MUTEX_INITIALIZER;
 int RilRequest::sNextSerial = 0;
@@ -685,7 +687,7 @@ void UnsolMessageManager::RegisterForMessage(int aMsgId, RilResponseHandler *aHa
   // multiple notifications to the same handler for any single message
   if (list->IndexOf(aHandler) != list->NoIndex) {
     // The provided handler was already registered for this message
-    QRLOGD("%s::Handler is already registered for this response", __FUNCTION__);
+    QRLOGV("%s::Handler is already registered for this response", __FUNCTION__);
     pthread_mutex_unlock(&mForwardingListsMutex);
     return;
   }
@@ -863,6 +865,16 @@ RIL::RIL(int aClientId) :
 #endif
     mImsSocket = new RilSocket(this, socketName, false);
   }
+  int dc_enabled = GetPropInt(PROP_DATA_COLLECTOR_ENABLED,false);
+  QLOGD(" ril: NetworkDataCollector: enable check = %d",dc_enabled);
+  if(dc_enabled) {
+      QLOGE(" ril: NetworkDataCollector: initialization");
+      // Create network data collector class instance
+      mNetworkDataCollector = new NetworkDataCollector(this);
+      mNetworkDataCollector->Initialize();
+   } else {
+       QLOGE(" ril: persist.radio.dc.enabled: disabled in system property");
+   }
 }
 
 /**
diff --git a/b2g_telephony/RILHelper.cpp b/b2g_telephony/RILHelper.cpp
index 0948303..6d30a6b 100755
--- a/b2g_telephony/RILHelper.cpp
+++ b/b2g_telephony/RILHelper.cpp
@@ -401,6 +401,43 @@ invalid:
 }
 
 /**
+ * Returns a size and byte buffer
+ */
+    RESPONSE_IMP(ResponseUnsolRaw) {
+      RILResult result;
+      int32_t len = -1;
+      uint8_t *data = nullptr;
+
+      startResponse;
+      ERR_TRY(p.readInt32(&len));
+
+      // Copy data only if this OEM_RAW response actually contains data
+      if ((len > 0) && ((size_t) len <= p.dataAvail())) {
+        data = (uint8_t*) alloca(len);
+        if (!ReadByteBuffer(p, len, &data)) {
+          goto invalid;
+        }
+        appendPrintBuf("len=%d,buf=\"%s\"", len, BytesToHexString(data, len).get());
+      } else {
+        appendPrintBuf("len=%d", len);
+      }
+
+      closeResponse;
+      printResponse;
+
+      // Check if there is a handler for this request as some requesters do not
+      // expect an answer.
+      if (handler) {
+        SEND_RESPONSE(handler, isSolicited,result.ForMessage(messageID, userObj,
+            data, len, error));
+      }
+      return;
+
+    invalid:
+      invalidCommandBlock (messageID);
+    }
+
+/**
  *
  */
 RESPONSE_IMP(ResponseCdmaCallWaiting) {
diff --git a/b2g_telephony/include/NetworkDataCollector.h b/b2g_telephony/include/NetworkDataCollector.h
new file mode 100644
index 0000000..0a5a72c
--- /dev/null
+++ b/b2g_telephony/include/NetworkDataCollector.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2012-2013,2017 Qualcomm Technologies, Inc.
+ * All Rights Reserved.
+ * Confidential and Proprietary - Qualcomm Technologies, Inc
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2012 Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NETWORK_DATA_COLLECTOR_H
+#define NETWORK_DATA_COLLECTOR_H
+
+#include "RIL.h"
+
+class RIL;
+class RILResult;
+class RilSocket;
+class OemRequest;
+class RilResponseHandler;
+
+
+typedef struct
+{
+    int32_t rsrp;
+    int32_t rsrq;
+    int32_t sinr;
+    int32_t activeband;
+    uint32_t lte_earfcn;
+    int32_t  srv_status;
+    int32_t timing_advance;
+    int32_t Roaming_Indicator;
+    int32_t sip_reg_status;
+    int32_t tac;
+}qmi_ril_nw_data_collector_Params;
+
+class DataCollectorSocket {
+public:
+  DataCollectorSocket(NetworkDataCollector* ril, const nsACString& name, bool useRilApi,
+      void (*dcCallback)(void*) = nullptr);
+  ~DataCollectorSocket();
+  const char* GetName();
+  void Close();
+  void Shutdown();
+  void OnDisconnect(bool isShuttingDown);
+  int mFd;
+  bool mUseRilApi;
+
+private:
+  nsCString mName;
+  RefPtr<NetworkDataCollector> mReceiver;
+  nsCOMPtr<nsIThread> mThread;
+};
+
+/**
+ * This class provides method to send RIL messages to
+ * oem socket on a {@code mDataCollectorThread thread}
+ */
+class NetworkDataCollector : public nsRunnable, public ImsResponseHandler {
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(NetworkDataCollector);
+  NetworkDataCollector(RIL* ril);
+  void Initialize();
+  NS_IMETHOD Run();
+  NS_IMETHODIMP sendHandShakeMsgToServer();
+  void HandleRilSolicitedResponse(RILResult& result);
+  void HandleRilUnSolicitedResponse(RILResult& result);
+  void HandleImsSolicitedResponse(RILResult& result);
+  void HandleImsUnSolicitedResponse(RILResult& result);
+  void  SendNetworkDataToServer(DataCollectorEventCodes event);
+  void  SendCallTriggeredDataToServer();
+  void  SendCallAttemptFailedDataToServer();
+  void  SendCallEstablishedDataToServer();
+  void  SendCallDisconnectDataToServer();
+  void  SendCallDropDataToServer();
+  void  SendTacUpdateDataToServer();
+  void HandleDataCollectorEvent( int eventType);
+  void Shutdown();
+  std::string tohex(const  std::string& s, bool upper=true);
+  friend class RilResponseHandler;
+  friend class RIL;
+
+private:
+  ~NetworkDataCollector();
+  nsresult SendRequest(uint32_t aClientId, OemRequest* aRr,  bool aAsyncRequest, uint32_t* aResult, const uint8_t** aResponse,  uint32_t* aRespLength);
+  nsresult WaitForResponse(uint32_t* aResult,  const uint8_t** aResponse, uint32_t* aRespLength);
+  void sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event);
+  const char* getDataCollectorEventCode(DataCollectorEventCodes eventType);
+  RIL* mRil;
+  DataCollectorSocket* mSocket;
+    // Used to simulate synchronous calls
+  pthread_mutex_t mSyncMutex;
+  uint32_t mResult;
+  bool mReceivedResponse;
+  nsTArray<uint8_t> mResponse;
+  RefPtr<NetworkDataCollector> mNetworkDataCollector;
+  nsCOMPtr<nsIThread> mDataCollectorThread;
+  bool mServerReady;
+  bool mShuttingDown;
+  nsCOMPtr<nsIThread> mThread;
+  nsCOMPtr<nsIThread> mDataCollectorSenderThread;
+  uint64_t mSeqNumber;
+  DataCollectorEventCodes mSenderEvent;
+  uint32_t mRilLastFailCause;
+};
+
+#endif // NETWORK_DATA_COLLECTOR_H
+
diff --git a/b2g_telephony/include/RIL.h b/b2g_telephony/include/RIL.h
index 1fec477..945ed04 100755
--- a/b2g_telephony/include/RIL.h
+++ b/b2g_telephony/include/RIL.h
@@ -88,6 +88,9 @@ const char* RequestToString(int request);
 #define QRIL_EVT_HOOK_SET_IS_DATA_ROAMING_ENABLED QRIL_EVT_HOOK_BASE + 41
 #define QRIL_EVT_HOOK_SET_APN_INFO                QRIL_EVT_HOOK_BASE + 42
 
+#define  QRIL_EVT_HOOK_NAS_BASE                                       QRIL_EVT_HOOK_BASE + 6300
+#define  QRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS     QRIL_EVT_HOOK_NAS_BASE + 1
+
 /* Constants for response types */
 #define RESPONSE_SOLICITED 0
 #define RESPONSE_UNSOLICITED 1
@@ -128,6 +131,41 @@ typedef enum {
   SOCKETID_IMS,
 } SocketId;
 
+enum DataCollectorEventCodes {
+    DATA_COLLECTOR_EVENT_CALL_TRIGGERED,
+    DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED,
+    DATA_COLLECTOR_EVENT_CALL_ESTABLISHED,
+    DATA_COLLECTOR_EVENT_CALL_DISCONNECT,
+    DATA_COLLECTOR_EVENT_CALL_DROP,
+    DATA_COLLECTOR_EVENT_CALL_MUTING,
+    DATA_COLLECTOR_EVENT_SMS_SENT,
+    DATA_COLLECTOR_EVENT_SMS_RECIVED,
+    DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT,
+    DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST,
+    DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT,
+    DATA_COLLECTOR_EVENT_OUT_OF_SERVICE,
+    DATA_COLLECTOR_EVENT_IN_SERVICE,
+    DATA_COLLECTOR_EVENT_ATTACH_FAILURE,
+    DATA_COLLECTOR_EVENT_TAC_UPDATE,
+    DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM,
+    DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE,
+    DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE,
+    DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE,
+    DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER,
+    DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER,
+    DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER,
+    DATA_COLLECTOR_EVENT_CELL_RESELECTION,
+    DATA_COLLECTOR_EVENT_RACH_FAILURE,
+    DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL,
+    DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL
+};
+
+typedef struct {
+    int32_t unsol_event;
+    int32_t data_len;
+    uint8_t* data;
+}unsol_data_struct_t;
+
 // Forward declarations
 class RIL;
 class RILResult;
@@ -139,6 +177,7 @@ class ImsPhone;
 class SmsMessage;
 class RilResponseHandler;
 class ResponseRunnable;
+class NetworkDataCollector;
 
 /* RIL Response structures */
 typedef struct {
@@ -645,6 +684,8 @@ public:
   friend class RilReceiver;
   friend class RilSender;
   friend class ResponseRunnable;
+  friend class NetworkDataCollector;
+  RefPtr<NetworkDataCollector> mNetworkDataCollector;
 
 protected:
   virtual ~RIL();
diff --git a/b2g_telephony/include/RILHelper.h b/b2g_telephony/include/RILHelper.h
index e666896..359cf1d 100755
--- a/b2g_telephony/include/RILHelper.h
+++ b/b2g_telephony/include/RILHelper.h
@@ -59,6 +59,7 @@ public:
   ADD_RESPONSE(OperatorInfos);
   ADD_RESPONSE(GetBroadcastConfig);
   ADD_RESPONSE(Raw);
+  ADD_RESPONSE(UnsolRaw);
   ADD_RESPONSE(CdmaCallWaiting);
   ADD_RESPONSE(CdmaInfoRecords);
   ADD_RESPONSE(LastCallFailCause);
diff --git a/b2g_telephony/include/RIL_unsol_commands.h b/b2g_telephony/include/RIL_unsol_commands.h
index 9cce9f7..19a3e54 100755
--- a/b2g_telephony/include/RIL_unsol_commands.h
+++ b/b2g_telephony/include/RIL_unsol_commands.h
@@ -52,7 +52,7 @@
     COMMAND_INFO(RIL_UNSOL_CDMA_CALL_WAITING, RILHelper::ResponseCdmaCallWaiting),
     COMMAND_INFO(RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, RILHelper::ResponseInts),
     COMMAND_INFO(RIL_UNSOL_CDMA_INFO_REC, RILHelper::ResponseCdmaInfoRecords),
-    COMMAND_INFO(RIL_UNSOL_OEM_HOOK_RAW, RILHelper::ResponseNotSupported),
+    COMMAND_INFO(RIL_UNSOL_OEM_HOOK_RAW, RILHelper::ResponseUnsolRaw),
     COMMAND_INFO(RIL_UNSOL_RINGBACK_TONE, RILHelper::ResponseInts),
     COMMAND_INFO(RIL_UNSOL_RESEND_INCALL_MUTE, RILHelper::ResponseNotSupported),
     COMMAND_INFO(RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, RILHelper::ResponseInts),
diff --git a/qcril/qcril_qmi/qcril.c b/qcril/qcril_qmi/qcril.c
index 9aa82d3..a94acf0 100755
--- a/qcril/qcril_qmi/qcril.c
+++ b/qcril/qcril_qmi/qcril.c
@@ -762,6 +762,7 @@ static qcril_dispatch_table_entry_type qcril_event_table[] =
   { QCRIL_REG_ALL_ACTIVE_STATES( QCRIL_EVT_HOOK_SET_RFM_SCENARIO_REQ ,  qcril_qmi_nas_set_rfm_scenario_req) },
   { QCRIL_REG_ALL_ACTIVE_STATES( QCRIL_EVT_HOOK_GET_RFM_SCENARIO_REQ ,  qcril_qmi_nas_get_rfm_scenario_req) },
   { QCRIL_REG_ALL_ACTIVE_STATES( QCRIL_EVT_HOOK_GET_PROVISIONED_TABLE_REVISION_REQ ,  qcril_qmi_nas_get_provisioned_table_revision_req) },
+  {QCRIL_REG_ALL_ACTIVE_STATES( QCRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS_REQ, qcril_qmi_nas_get_nw_data_collector_params_req)},
 
   /**********************************************
    *           CM                               *
@@ -5343,6 +5344,8 @@ RIL_Errno qmi_ril_parse_oem_hook_header ( unsigned char *data, qmi_ril_oem_hook_
       case QCRIL_EVT_HOOK_GET_MODEM_CAPABILITY:
       case QCRIL_EVT_HOOK_UPDATE_SUB_BINDING:
       case QCRIL_EVT_HOOK_REJECT_INCOMING_CALL_CAUSE_21:
+      case QCRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS_REQ:
+
       case QCRIL_EVT_HOOK_SET_LTE_TUNE_AWAY:
         outcome_data.is_oem_hook    = TRUE;
         outcome_data.hook_req       = cmd_id;
diff --git a/qcril/qcril_qmi/qcril_log.c b/qcril/qcril_qmi/qcril_log.c
index 36f48f6..b049e1a 100755
--- a/qcril/qcril_qmi/qcril_log.c
+++ b/qcril/qcril_qmi/qcril_log.c
@@ -1163,6 +1163,12 @@ const char *qcril_log_lookup_event_name
       case QCRIL_EVT_HOOK_UNSOL_MAX_DATA_CHANGE_IND:
         return "QCRIL_EVT_HOOK_UNSOL_MAX_DATA_CHANGE_IND";
 
+      case QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND:
+        return "QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND";
+
+      case QCRIL_EVT_HOOK_UNSOL_RIL_LAST_FAIL_CAUSE_IND:
+        return "QCRIL_EVT_HOOK_UNSOL_RIL_LAST_FAIL_CAUSE_IND";
+
       case QCRIL_EVT_HOOK_GET_MAX_DATA_ALLOWED_REQ:
         return "QCRIL_EVT_HOOK_GET_MAX_DATA_ALLOWED_REQ";
 
diff --git a/qcril/qcril_qmi/qcril_qmi_nas.c b/qcril/qcril_qmi/qcril_qmi_nas.c
index 6ee448f..5f09ac0 100755
--- a/qcril/qcril_qmi/qcril_qmi_nas.c
+++ b/qcril/qcril_qmi/qcril_qmi_nas.c
@@ -833,6 +833,23 @@ typedef struct
 
 } qmi_ril_reg_reject_cached_summary_type;
 
+int8 is_data_collector_available =1;
+
+struct qmi_ril_nw_data_collector_Param
+{
+    int32_t rsrp;
+    int32_t rsrq;
+    int32_t snr;
+    int32_t activeband;
+    uint32_t lte_earfcn;
+    int32_t  srv_status;
+    int32_t timing_advance;
+    int32_t Roaming_Indicator;
+    int32_t sip_reg_status;
+    int32_t tac;
+};
+struct qmi_ril_nw_data_collector_Param qmi_ril_nw_data_collector_Params;
+
 typedef struct
 {
     uint8_t rat;
@@ -3004,6 +3021,7 @@ void qcril_qmi_nas_init()
 
     int                         op_mode_valid;
     dms_operating_mode_enum_v01 op_mode;
+    memset(&qmi_ril_nw_data_collector_Params,0,sizeof(qmi_ril_nw_data_collector_Params));
 
     QCRIL_LOG_FUNC_ENTRY();
 
@@ -4741,6 +4759,13 @@ void qcril_qmi_nas_retrieve_rf_band_info()
         }
       }
 
+     if((1 == rf_band_info_len ) && ( NAS_RADIO_IF_LTE_V01 == qmi_response.rf_band_info_list[0].radio_if) && is_data_collector_available ){
+          is_data_collector_available = 0;
+          qmi_ril_nw_data_collector_Params.activeband = qmi_response.rf_band_info_list[0].active_band;
+          QCRIL_LOG_DEBUG( "LTE :active band =  %d", qmi_ril_nw_data_collector_Params.activeband );
+          is_data_collector_available = 1;
+      }
+
       qcril_qmi_nas_coex_control_process_rf_band_info(rf_band_info_arr, rf_band_info_len);
     }
 
@@ -6112,7 +6137,6 @@ void qcril_qmi_nas_unsolicited_indication_cb_helper
                                   result);
                   break;
                }
-
                NAS_CACHE_LOCK();
                is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
                NAS_CACHE_UNLOCK();
@@ -8501,6 +8525,12 @@ int qcril_qmi_nas_sys_info_ind_conv_qmi2ril(nas_sys_info_ind_msg_v01 * qmi_msg,
        *network_state_updated = ( nas_common_info.location_updates_enabled &&
                                 ( ( prev_sys_info_helper.lte_only_sys_info->tac_valid && cur_sys_info_helper.lte_only_sys_info->tac_valid ) &&
                                   ( prev_sys_info_helper.lte_only_sys_info->tac != cur_sys_info_helper.lte_only_sys_info->tac ) ) );
+       if( *network_state_updated) {
+       //sendt tac update unsol from here.
+           uint8_t dataCollectorEvents = DATA_COLLECTOR_EVENT_TAC_UPDATE;
+               QCRIL_LOG_INFO("data collector indication - %d", dataCollectorEvents);
+           qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
+       }
      }
    }
    // Check for location update for CDMA
@@ -9425,7 +9455,6 @@ void qmi_ril_nw_reg_update_serving_system_cache_from_ind( nas_serving_system_ind
     NAS_CACHE_STORE_ENTRY( nas_cached_info.mnc_includes_pcs_digit, qmi_msg->mnc_includes_pcs_digit );
     NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.hs_call_status, qmi_msg->hs_call_status );
 
-
     if ( NAS_VAL_REGISTERED == qmi_msg->serving_system.registration_state )
     {
         NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.registration_reject_reason );
@@ -12761,6 +12790,7 @@ void qcril_qmi_nas_request_data_registration_state
 
   qmi_ril_suppress_android_unsol_resp(RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED);
   qmi_ril_suppress_android_unsol_resp(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED);
+
   NAS_CACHE_LOCK();
 
   if ( !qmi_ril_is_qmi_sys_info_available() )
@@ -43794,6 +43824,235 @@ void qcril_qmi_nas_start_timer_if_early_radio_power_req_came()
     QCRIL_LOG_FUNC_RETURN();
 }
 
+static void qcril_qmi_nas_send_request_reponse
+(
+  qcril_instance_id_e_type instance_id,
+  RIL_Token t,
+  int request_id,
+  RIL_Errno err_no,
+  void *data,
+  int data_size
+)
+{
+    qcril_request_resp_params_type resp;
+
+    QCRIL_LOG_FUNC_ENTRY();
+    qcril_default_request_resp_params(instance_id, t, request_id, err_no, &resp);
+    if (NULL != data && data_size > 0 && RIL_E_SUCCESS == err_no)
+    {
+       resp.resp_pkt = data;
+       resp.resp_len = data_size;
+    }
+    qcril_send_request_response(&resp);
+    QCRIL_LOG_FUNC_RETURN();
+}
+
+
+void qcril_qmi_nas_get_nw_data_collector_params_req
+(
+  const qcril_request_params_type *const params_ptr,
+  qcril_request_return_type *const ret_ptr
+)
+{
+    qcril_instance_id_e_type instance_id;
+    nas_get_cell_location_info_resp_msg_v01 get_cell_info_resp;
+    imsa_get_registration_status_resp_msg_v01 get_ims_reg_resp;
+    uint16_t           qmi_request_mask = NAS_NIL;
+    nas_get_signal_strength_req_msg_v01 get_signal_strength_req;
+    nas_get_signal_strength_resp_msg_v01  * get_signal_strength_resp = NULL;
+    nas_get_serving_system_resp_msg_v01 * qmi_serving_system_response = NULL;
+    qmi_client_error_type qmi_client_error;
+    nas_get_sig_info_resp_msg_v01 qmi_response_sig_info;
+    RIL_Errno ril_req_res = RIL_E_SUCCESS;
+     imsa_get_rtp_statistics_resp_msg_v01 rtp_statistics_response_msg;
+
+
+    QCRIL_LOG_FUNC_ENTRY();
+    instance_id = QCRIL_DEFAULT_INSTANCE_ID;
+    QCRIL_NOTUSED( ret_ptr );
+
+    memset(&get_cell_info_resp, 0, sizeof(get_cell_info_resp));
+    memset(&get_ims_reg_resp, 0, sizeof(get_ims_reg_resp));
+    if( E_SUCCESS !=
+         qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
+                                             QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01, /* msg_id */
+                                             NULL,                                         /* *req_c_struct */
+                                             0,                                            /* req_c_struct_len */
+                                             &get_cell_info_resp,                    /* *resp_c_struct */
+                                             sizeof(get_cell_info_resp),              /* resp_c_struct_len */
+                                             QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
+                                            ) )
+   { /* error occurred during sending a message */
+        QCRIL_LOG_ERROR(" qcril_qmi_client_send_msg_sync returned erro for CELL_LOCATION");
+   }
+   else
+    { /* message sending was successful and got the response */
+        /* check for standard response */
+        if(QMI_RESULT_SUCCESS_V01 != get_cell_info_resp.resp.result)
+        {
+            QCRIL_LOG_ERROR("get Cell info error %d", get_cell_info_resp.resp.result);
+        }
+        else
+        { /* successful */
+            if (is_data_collector_available == 1)
+            {
+                is_data_collector_available = 0;
+                /* set response data */
+                if(get_cell_info_resp.lte_intra_earfcn_valid)
+                {
+                    qmi_ril_nw_data_collector_Params.lte_earfcn = get_cell_info_resp.lte_intra_earfcn;
+                }
+                if(get_cell_info_resp.timing_advance_valid)
+                {
+                    qmi_ril_nw_data_collector_Params.timing_advance = get_cell_info_resp.timing_advance;
+                }
+                is_data_collector_available = 1;
+            }
+        }
+    }
+    if( E_SUCCESS !=
+         qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_IMSA ),
+                                             QMI_IMSA_GET_REGISTRATION_STATUS_REQ_V01, /* msg_id */
+                                             NULL,                                         /* *req_c_struct */
+                                             0,                                            /* req_c_struct_len */
+                                             &get_ims_reg_resp,                    /* *resp_c_struct */
+                                             sizeof(get_ims_reg_resp),              /* resp_c_struct_len */
+                                             QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
+                                            ) )
+   { /* error occurred during sending a message */
+        QCRIL_LOG_ERROR(" qcril_qmi_client_send_msg_sync returned erro for IMSA REG STATUS");
+   }
+   else
+   {
+       /* message sending was successful and got the response */
+       /* check for standard response */
+       if(QMI_RESULT_SUCCESS_V01 != get_ims_reg_resp.resp.result)
+       {
+           QCRIL_LOG_ERROR(" get IMS reg status error %d", get_ims_reg_resp.resp.result);
+       }
+       else
+       {
+           /* successful */
+           if (is_data_collector_available == 1)
+           {
+               is_data_collector_available = 0;
+               /* set response data */
+               if(get_ims_reg_resp.ims_registered_valid)
+               {
+                   qmi_ril_nw_data_collector_Params.sip_reg_status = get_ims_reg_resp.ims_registered ;
+               }
+               is_data_collector_available = 1;
+           }
+       }
+   }
+
+   memset( &qmi_response_sig_info, 0, sizeof( qmi_response_sig_info ) );
+   qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
+                                                                                                                      QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
+                                                                                                                      NULL,
+                                                                                                                      NAS_NIL,
+                                                                                                                      &qmi_response_sig_info,
+                                                                                                                      sizeof( qmi_response_sig_info ),
+                                                                                                                      QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
+
+   ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response_sig_info.resp );
+   if ( RIL_E_SUCCESS == ril_req_res )
+   {
+           if (is_data_collector_available == 1)
+                   {
+                           is_data_collector_available = 0;
+                if (qmi_response_sig_info.lte_sig_info_valid) {
+                    qmi_ril_nw_data_collector_Params.rsrp = qmi_response_sig_info.lte_sig_info.rsrp;
+                    qmi_ril_nw_data_collector_Params.rsrq = qmi_response_sig_info.lte_sig_info.rsrq;
+                    qmi_ril_nw_data_collector_Params.snr = qmi_response_sig_info.lte_sig_info.snr;
+                } else {
+                   QCRIL_LOG_ERROR("get QMI_NAS_GET_SIG_INFO_REQ_MSG_V01 invalid lte sig info ");
+                }
+                is_data_collector_available = 1;
+           }
+   } else {
+       QCRIL_LOG_ERROR("get QMI_NAS_GET_SIG_INFO_REQ_MSG_V01 status error %d", ril_req_res);
+   }
+
+    qmi_serving_system_response = qcril_malloc( sizeof( *qmi_serving_system_response ) );
+    if ( qmi_serving_system_response )
+    {
+
+        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
+                                                           QMI_NAS_GET_SERVING_SYSTEM_REQ_MSG_V01,
+                                                           NULL,
+                                                           NAS_NIL,  // empty request payload
+                                                           (void*) qmi_serving_system_response,
+                                                           sizeof( *qmi_serving_system_response ),
+                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
+
+
+        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_serving_system_response->resp );
+
+
+        if ( RIL_E_SUCCESS == ril_req_res )
+        {
+              if (is_data_collector_available == 1)
+              {
+                   is_data_collector_available = 0;
+                   qmi_ril_nw_data_collector_Params.srv_status = qmi_serving_system_response->serving_system.registration_state;
+                    qmi_ril_nw_data_collector_Params.Roaming_Indicator =   qmi_serving_system_response->roaming_indicator;
+                    is_data_collector_available = 1;
+             }
+        } else {
+               /* message sending was successful and got the response */
+               /* check for standard response */
+              QCRIL_LOG_ERROR("get QMI_NAS_GET_SERVING_SYSTEM_REQ_MSG_V01 status error %d", ril_req_res);
+        }
+        qcril_free( qmi_serving_system_response );
+     }else {
+            QCRIL_LOG_ERROR("malloc failed for QMI_NAS_GET_SERVING_SYSTEM_REQ_MSG_V01");
+     }
+
+     NAS_CACHE_LOCK();
+     if(nas_cached_info.lte_sys_info_valid && nas_cached_info.lte_sys_info->lte_specific_sys_info.tac_valid) {
+         //copy tac value.
+         qmi_ril_nw_data_collector_Params.tac =nas_cached_info.lte_sys_info->lte_specific_sys_info.tac;
+     } else {
+         qmi_ril_nw_data_collector_Params.tac = 0;//default value
+     }
+     NAS_CACHE_UNLOCK();
+
+   qcril_qmi_nas_retrieve_rf_band_info();
+
+    if( E_SUCCESS !=
+         qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_IMSA ),
+                                             QMI_IMSA_GET_RTP_STATISTICS_REQ_V01, /* msg_id */
+                                             NULL,                                         /* *req_c_struct */
+                                             0,                                            /* req_c_struct_len */
+                                             &rtp_statistics_response_msg,                    /* *resp_c_struct */
+                                             sizeof(rtp_statistics_response_msg),              /* resp_c_struct_len */
+                                             QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
+                                            ) )
+   { /* error occurred during sending a message */
+        QCRIL_LOG_ERROR(" qcril_qmi_client_send_msg_sync returned erro for IMSA REG STATUS");
+   }
+   else
+   {
+       /* message sending was successful and got the response */
+       /* check for standard response */
+       if(QMI_RESULT_SUCCESS_V01 != get_ims_reg_resp.resp.result)
+       {
+           QCRIL_LOG_ERROR(" get QMI_IMSA_GET_RTP_STATISTICS_REQ_V01 status error %d", get_ims_reg_resp.resp.result);
+       }
+       else
+       {
+           /* successful */
+               QCRIL_LOG_INFO("calling QMI_IMSA_GET_RTP_STATISTICS_REQ_V01 successful");
+       }
+   }
+
+   /* Send the response to UI */
+   qcril_qmi_nas_send_request_reponse(instance_id, params_ptr->t, params_ptr->event_id,
+                                        RIL_E_SUCCESS, (void *)&qmi_ril_nw_data_collector_Params, sizeof(qmi_ril_nw_data_collector_Params));
+   QCRIL_LOG_FUNC_RETURN();
+}
+
 int qcril_qmi_nas_evaluate_data_rat_to_decide_ccs()
 {
     int current_data_tech = RADIO_TECH_UNKNOWN;
diff --git a/qcril/qcril_qmi/qcril_qmi_nas.h b/qcril/qcril_qmi/qcril_qmi_nas.h
index ec32ad6..72708dd 100755
--- a/qcril/qcril_qmi/qcril_qmi_nas.h
+++ b/qcril/qcril_qmi/qcril_qmi_nas.h
@@ -1443,6 +1443,16 @@ void qcril_qmi_nas_get_provisioned_table_revision_req
   qcril_request_return_type *const ret_ptr
 );
 
+ /*=========================================================================
+  FUNCTION:  qcril_qmi_nas_get_nw_data_collector_params_req
+
+===========================================================================*/
+void qcril_qmi_nas_get_nw_data_collector_params_req
+(
+  const qcril_request_params_type *const params_ptr,
+  qcril_request_return_type *const ret_ptr
+);
+
 /*=========================================================================
   FUNCTION:  qcril_qmi_nas_embms_set_enable_cmd_cb_helper
 
diff --git a/qcril/qcril_qmi/qcril_qmi_voice.c b/qcril/qcril_qmi/qcril_qmi_voice.c
index 8c3eed4..d7ebce5 100755
--- a/qcril/qcril_qmi/qcril_qmi_voice.c
+++ b/qcril/qcril_qmi/qcril_qmi_voice.c
@@ -3822,6 +3822,8 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
   char  callID[5] = "\0";
   int rc = 0;
 
+  uint8_t dataCollectorEvents = 0;
+
   int32_t iter_media_id = INVALID_MEDIA_ID;
 
   uint8_t is_connected_number_ECT_valid;
@@ -4800,6 +4802,9 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
             }
 
             qcril_qmi_voice_set_cdma_call_id_if_applicable_vcl(iter_call_info);
+            dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_ESTABLISHED;
+            QCRIL_LOG_INFO("initiate data collector indication id - %d", dataCollectorEvents);
+            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
 
             break; // end of case CALL_STATE_CONVERSATION_V02
 
@@ -4983,6 +4988,21 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
             {
               qcril_qmi_voice_enable_voice_indications(FALSE);
             }
+            //Only MO call can have call attempt failure
+            if(((call_info_entry->voice_scv_info.call_state == CALL_STATE_ORIGINATING_V02) ||
+                (call_info_entry->voice_scv_info.call_state  == CALL_STATE_CC_IN_PROGRESS_V02)) &&
+                (call_info_entry->lcf_valid && (call_info_entry->lcf != CALL_FAIL_NORMAL))) {
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED;
+            } else if (call_info_entry->lcf_valid && call_info_entry->lcf == CALL_FAIL_NORMAL) {
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_DISCONNECT;
+            } else {
+                dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_DROP;
+            }
+            if(call_info_entry->lcf_valid) {
+                QCRIL_LOG_ESSENTIAL("Initiate data collector last failed cause - %d", call_info_entry->lcf);
+                qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_RIL_LAST_FAIL_CAUSE_IND, &call_info_entry->lcf, sizeof(call_info_entry->lcf));            
+            }
+            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
             break; // end of case CALL_STATE_END_V02
 
           case CALL_STATE_ORIGINATING_V02:
@@ -5172,12 +5192,16 @@ void qcril_qmi_voice_all_call_status_ind_hdlr
             }
 
             qcril_qmi_voice_set_cdma_call_id_if_applicable_vcl(iter_call_info);
+            dataCollectorEvents = DATA_COLLECTOR_EVENT_CALL_TRIGGERED;
+            QCRIL_LOG_INFO("Indicate data collector indication id - %d", dataCollectorEvents);
+            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND, &dataCollectorEvents, sizeof(dataCollectorEvents));
 
             break; // end of case CALL_STATE_ORIGINATING_V02
 
           case CALL_STATE_DISCONNECTING_V02:
             QCRIL_LOG_ESSENTIAL("call state DISCONNECTING for conn id %d", iter_call_info->call_id);
 
+
             call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( iter_call_info->call_id );
             if ( call_info_entry )
             {
diff --git a/qcril/qcril_qmi/qcrili.h b/qcril/qcril_qmi/qcrili.h
index c73f3a2..6c1b7cc 100755
--- a/qcril/qcril_qmi/qcrili.h
+++ b/qcril/qcril_qmi/qcrili.h
@@ -652,6 +652,8 @@ typedef enum
   QCRIL_EVT_HOOK_UNSOL_CSG_ID_CHANGE_IND    = QCRIL_EVT_HOOK_BASE + 1052,
   QCRIL_EVT_HOOK_UNSOL_RAT_RAC_CHANGE_IND    = QCRIL_EVT_HOOK_BASE + 1053,
   QCRIL_EVT_HOOK_UNSOL_MAX_DATA_CHANGE_IND    = QCRIL_EVT_HOOK_BASE + 1054,
+  QCRIL_EVT_HOOK_UNSOL_NW_DATA_COLLECTOR_IND  = QCRIL_EVT_HOOK_BASE + 1055,
+  QCRIL_EVT_HOOK_UNSOL_RIL_LAST_FAIL_CAUSE_IND  = QCRIL_EVT_HOOK_BASE + 1056,
 
   QCRIL_EVT_HOOK_UNSOL_PCSCF_ADDR            = QCRIL_EVT_HOOK_BASE + 1060,
   QCRIL_EVT_HOOK_UNSOL_OPERATOR_RESERVED_PCO = QCRIL_EVT_HOOK_BASE + 1061,
@@ -734,6 +736,9 @@ typedef enum
   QCRIL_EVT_HOOK_GET_RFM_SCENARIO_REQ               = QCRIL_EVT_HOOK_RFPE_BASE + 2,
   QCRIL_EVT_HOOK_GET_PROVISIONED_TABLE_REVISION_REQ = QCRIL_EVT_HOOK_RFPE_BASE + 3,
 
+  QCRIL_EVT_HOOK_NAS_BASE                                       = QCRIL_EVT_HOOK_BASE + 6300,
+  QCRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS_REQ           = QCRIL_EVT_HOOK_NAS_BASE + 1 ,
+
   QCRIL_EVT_HOOK_MAX,
 
   QCRIL_EVT_OEM_BASE                           = 0x90000,
@@ -1070,6 +1075,36 @@ typedef struct {
     int  current_sub_preference;   // Current SIM provisioning status  0 - Deactivate, 1 - Activate
 } RIL_SubProvStatus;
 
+typedef enum  {
+    DATA_COLLECTOR_EVENT_CALL_TRIGGERED,
+    DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED,
+    DATA_COLLECTOR_EVENT_CALL_ESTABLISHED,
+    DATA_COLLECTOR_EVENT_CALL_DISCONNECT,
+    DATA_COLLECTOR_EVENT_CALL_DROP,
+    DATA_COLLECTOR_EVENT_CALL_MUTING,
+    DATA_COLLECTOR_EVENT_SMS_SENT,
+    DATA_COLLECTOR_EVENT_SMS_RECIVED,
+    DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT,
+    DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST,
+    DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT,
+    DATA_COLLECTOR_EVENT_OUT_OF_SERVICE,
+    DATA_COLLECTOR_EVENT_IN_SERVICE,
+    DATA_COLLECTOR_EVENT_ATTACH_FAILURE,
+    DATA_COLLECTOR_EVENT_TAC_UPDATE,
+    DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM,
+    DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE,
+    DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE,
+    DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE,
+    DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER,
+    DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER,
+    DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER,
+    DATA_COLLECTOR_EVENT_CELL_RESELECTION,
+    DATA_COLLECTOR_EVENT_RACH_FAILURE,
+    DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL,
+    DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL
+}Data_Collector_Event_e_type;
+
+
 #ifndef RIL_REQUEST_SET_RADIO_CAPABILITY
 #define RIL_REQUEST_SET_RADIO_CAPABILITY 10117
 #endif
@@ -1875,6 +1910,7 @@ QCRIL_EXTERN (qmi_ims_presence_get_notify_fmt_req);
 QCRIL_EXTERN (qmi_ims_presence_send_unsubscribe_req);
 QCRIL_EXTERN (qmi_ims_presence_get_event_report_req);
 QCRIL_EXTERN (qmi_ims_presence_set_event_report_req);
+QCRIL_EXTERN (qmi_nas_get_nw_data_collector_params_req);
 
 /* PBM */
 QCRIL_EXTERN (pbm_event_handler);
-- 
1.9.1

