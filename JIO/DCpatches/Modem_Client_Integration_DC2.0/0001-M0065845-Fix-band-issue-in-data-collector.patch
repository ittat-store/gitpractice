From 521f256bc2168e359f4464c2be15cd3b39de52cb Mon Sep 17 00:00:00 2001
From: Ranjit Mishra <ranjit.mishra@borqs.com>
Date: Fri, 3 Nov 2017 13:29:07 +0530
Subject: [PATCH 01/43] M0065845 : Fix band issue in data collector

- Report default band as 0 if modem provide band other than 3/5/40.
- convert the files from dos format to unix format

Change-Id: I083b21aa3ccce23c52966dfa310a5b91774ebb01
---
 b2g_telephony/NetworkDataCollector.cpp       | 1449 +++++++++++++-------------
 b2g_telephony/include/NetworkDataCollector.h |  248 ++---
 2 files changed, 849 insertions(+), 848 deletions(-)
 mode change 100644 => 100755 b2g_telephony/NetworkDataCollector.cpp
 mode change 100644 => 100755 b2g_telephony/include/NetworkDataCollector.h

diff --git a/b2g_telephony/NetworkDataCollector.cpp b/b2g_telephony/NetworkDataCollector.cpp
old mode 100644
new mode 100755
index 60ca835..0b18cf4
--- a/b2g_telephony/NetworkDataCollector.cpp
+++ b/b2g_telephony/NetworkDataCollector.cpp
@@ -1,724 +1,725 @@
-/*
- * Copyright (c) 2012-2015 Qualcomm Technologies, Inc.  All Rights Reserved.
- * Qualcomm Technologies Proprietary and Confidential.
- *
- * Not a Contribution, Apache license notifications and license are retained
- * for attribution purposes only.
- */
-
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "NetworkDataCollector.h"
-
-/* Logging related */
-#undef LOG_TAG
-#define LOG_TAG "NW_DATA_COLLECTOR"
-#include "LogUtils.h"
-#include <utils/SystemClock.h>
-#include <iostream>
-#include <fstream>
-#include <sys/un.h>
-#include "Conversion.h"
-#include <sstream>
-#include <iomanip>
-
-
-
-
-NS_NAMED_LITERAL_CSTRING(RILD_OEM_SOCKET_NAME, "qmux_radio/rild_oem");
-
-#define NETWORK_DATA_COLLECTOR_RETRY_SECONDS 60
-// Max time to wait for a response to an OEM hook request
-#define MAX_OEM_HOOK_REQ_TIME_MSEC 10 * 1000
-
-#define NETWORK_PARAMS_LOG_FILE       "/data/data/media/network_parameters.txt"
-
-NS_NAMED_LITERAL_CSTRING(DATA_COLLECTOR_SERVER_SOCKET_NAME, "/dev/socket/metricsd_socket");
-
-#define SERVER_DATA_COLLECTOR_SOCKET_NAME  "/dev/socket/metricsd_socket"
-// Amount of time to sleep while waiting for a response to allow yielding of
-// CPU to other threads
-#define SYNC_RSP_SLEEP_USEC 50 * 1000
-
-#define MAX_COMMAND_BYTES (8 * 1024)
-
-#define MAX_RESPONSE_BYTES 1024
-
-#define INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET  "{ \"source\": \"ril_metrics\" }"
-
-#define DATA_COLLECTOR_UNSOL_OEM_HOOK_RAW_IND  525343
-
-#define LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND 525344
-
-#define QCRIL_QMI_VOICE_MAX_FAIL_CAUSE_STR_LEN     256
-
-
-typedef struct
-{
-    uint8_t frameType;
-    uint32_t payloadLength;
-    int8_t* payload;
-}data_collector_frame;
-
-/*============= Implementation of Class DataCollectorSocket =============*/
-
-/**
- *
- */
-DataCollectorSocket::DataCollectorSocket(NetworkDataCollector* NWDataCollector, const nsACString& name, bool useRilApi,
-    void (*dcCallback)(void*))
-    : mFd(-1),
-      mUseRilApi(useRilApi),
-      mName(name) {
-    QLOGE("NetworkDataCollector : DataCollectorSocket initialize");
-    mReceiver = NWDataCollector;
-    RefPtr<nsRunnable> runnable = NS_NewRunnableMethod(mReceiver,
-                                                                  &NetworkDataCollector::Run);
-
-    // Start the RilReceiver thread for this socket
-    NS_NewThread(getter_AddRefs(mThread), runnable);
-}
-
-/*============= Implementation of Class RilSocket =============*/
-
-/**
- *
- */
-DataCollectorSocket::~DataCollectorSocket() {
-  Close();
-}
-
-/**
- * Get the name of the socket (i.e. "rild1")
- * Returns the name as a basic C string instead of nsCString since it is always
- * fed into functions that require a char * input.
- */
-const char* DataCollectorSocket::GetName() {
-    return mName.get();
-};
-
-void DataCollectorSocket::Shutdown() {
-    mReceiver->Shutdown();
-}
-
-/**
- * Closes a socket
- */
-void DataCollectorSocket::Close() {
-    if (mFd >= 0) {
-    close(mFd);
-    }
-    mFd = -1;
-}
-
-/**
- *
- */
-void DataCollectorSocket::OnDisconnect(bool isShuttingDown) {
-  Close();
-//  DispatchRunnable(mDisconnectRunnable, isShuttingDown);
-}
-
-
-/*============= Implementation of Class NetworkDataCollector =============*/
-
-/**
- *
- */
-NetworkDataCollector::NetworkDataCollector(RIL* ril) :ImsResponseHandler(ril), mRil(ril),
-                               mSyncMutex(PTHREAD_MUTEX_INITIALIZER), mResult(RIL_E_SUCCESS), mReceivedResponse(false),mServerReady(false),mShuttingDown(false) {
-    mSeqNumber = 1; // count starts from 1
-    mSenderEvent = DATA_COLLECTOR_EVENT_CALL_TRIGGERED;
-    mRilLastFailCause = CALL_FAIL_NORMAL_UNSPECIFIED;
-    mRil->RegisterForUnsol(RIL_UNSOL_OEM_HOOK_RAW, this);
-}
-
-NetworkDataCollector::~NetworkDataCollector() {
-      mRil->UnRegisterForUnsol(RIL_UNSOL_OEM_HOOK_RAW, this);
-}
- void NetworkDataCollector::Initialize() {
-    nsCString socketName;
-    socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
-    QLOGE("NetworkDataCollector  initialize");
-
-    mSocket = new DataCollectorSocket(this, socketName, true);
- }
-
- void NetworkDataCollector::Shutdown() {
-   mShuttingDown = true;
- }
-
- void NetworkDataCollector::HandleRilUnSolicitedResponse(RILResult& result) {
-     int messageID = result.mMessageID;
-     QLOGE("Received unsolicited response %s", RequestToString(messageID));
-
-     switch (messageID) {
-        case RIL_UNSOL_OEM_HOOK_RAW: {
-           uint8_t *p = nullptr;
-           p = (uint8_t* ) result.data;
-          QLOGE("HandleUnSolicitedResponse, data len = %d",result.datalen);
-          int index = 8; //starting index of event id and size.
-          if(result.datalen > 16) {
-             int event = (uint32_t)((p[index+3])  << 24 | (p[index+2]) << 16 | (p[index+1]) << 8 |(p[index]));
-             if(event == DATA_COLLECTOR_UNSOL_OEM_HOOK_RAW_IND) {
-                 int event_size = (uint32_t)((p[index+7])  << 24 | (p[index+6]) << 16 | (p[index+5]) << 8 |(p[index+4]));
-                 QLOGE("HandleUnSolicitedResponse, data collector event length = %d",event_size);
-                 if(event_size) {
-                     int eventType =  p[index+8];
-                     HandleDataCollectorEvent(eventType);
-                 }
-            }
-            if(event == LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND) {
-                 int event_size = (uint32_t)((p[index+7])  << 24 | (p[index+6]) << 16 | (p[index+5]) << 8 |(p[index+4]));
-                 QLOGE("HandleUnSolicitedResponse, last fail cause event length = %d",event_size);
-                 if(event_size) {
-                     mRilLastFailCause =  (uint32_t)((p[index+11])  << 24 | (p[index+10]) << 16 | (p[index+9]) << 8 |(p[index+8]));
-                     QLOGE("HandleUnSolicitedResponse, last fail cause  = %d",mRilLastFailCause);
-                     // RJIL do not support error higher value  then CALL_FAIL_DIAL_MODIFIED_TO_DIAL(246),
-                     //because those errors are for cdma network specific and JIO network does not expect that..
-                     if(mRilLastFailCause > CALL_FAIL_DIAL_MODIFIED_TO_DIAL) {
-                        mRilLastFailCause = CALL_FAIL_NORMAL_UNSPECIFIED;
-                     }
-                }
-            }
-          }
-       }
-       break;
-       default:
-          QLOGE("%s: unexpected request %s", __FUNCTION__, RequestToString(messageID));
-       break;
-      }
- }
-
-void  NetworkDataCollector::SendCallTriggeredDataToServer() {
-    QLOGE("%s new thread began", __FUNCTION__);
-    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_TRIGGERED);
-}
-
- void  NetworkDataCollector::SendCallAttemptFailedDataToServer() {
-     QLOGE("%s new thread began", __FUNCTION__);
-     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED);
- }
-
- void  NetworkDataCollector::SendCallEstablishedDataToServer() {
-    QLOGE("%s new thread began", __FUNCTION__);
-    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ESTABLISHED);
-}
-
- void  NetworkDataCollector::SendCallDisconnectDataToServer() {
-    QLOGE("%s new thread began", __FUNCTION__);
-    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DISCONNECT);
-}
-
- void  NetworkDataCollector::SendCallDropDataToServer() {
-    QLOGE("%s new thread began", __FUNCTION__);
-    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DROP);
-}
-
- void  NetworkDataCollector::SendTacUpdateDataToServer() {
-    QLOGE("%s new thread began", __FUNCTION__);
-    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_TAC_UPDATE);
-}
-
-
- void NetworkDataCollector::HandleDataCollectorEvent( int eventType) {
-    bool isValidType = true;
-    RefPtr<nsRunnable> runnable = nullptr;
-    QLOGE("%s event type = %d", __FUNCTION__,eventType);
-    switch(eventType) {
-        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
-            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallTriggeredDataToServer);
-            break;
-        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
-            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallAttemptFailedDataToServer);
-            break;
-        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
-            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallEstablishedDataToServer);
-            break;
-        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
-            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDisconnectDataToServer);
-            break;
-        case DATA_COLLECTOR_EVENT_CALL_DROP:
-            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDropDataToServer);
-            break;
-        case DATA_COLLECTOR_EVENT_CALL_MUTING:
-        case DATA_COLLECTOR_EVENT_SMS_SENT:
-        case DATA_COLLECTOR_EVENT_SMS_RECIVED:
-        case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
-        case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
-        case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
-        case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
-        case DATA_COLLECTOR_EVENT_IN_SERVICE:
-        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
-            isValidType = false;
-            break;
-        case DATA_COLLECTOR_EVENT_TAC_UPDATE:
-            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendTacUpdateDataToServer);
-            break;
-        case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
-        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
-        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
-        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
-        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
-        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
-        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
-        case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
-        case DATA_COLLECTOR_EVENT_RACH_FAILURE:
-        case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
-        case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
-        default:
-            isValidType = false;
-            break;
-
-        }
-
-      // Start the new  thread for this operation
-      if(isValidType)
-            NS_NewThread(getter_AddRefs(mDataCollectorSenderThread), runnable);
-    }
-
- /**
-  * Handles the solicited requests from RIL
-  *
-  * @param aResult The response data from the OEM hook request
-  */
- void NetworkDataCollector::HandleRilSolicitedResponse(RILResult& aResult) {
-    int messageID = aResult.mMessageID;
-    QLOGD("HandleSolicitedResponse %s", RequestToString(messageID));
-
-    if (messageID != RIL_REQUEST_OEM_HOOK_RAW) {
-       QLOGE("NetworkDataCollector Message %s not supported", RequestToString(messageID));
-       return;
-    }
-    qmi_ril_nw_data_collector_Params *nwParams = (qmi_ril_nw_data_collector_Params *)aResult.data;
-
-   mResponse.Clear();
-   mResult = aResult.mError;
-
-   // Even for success case, result data can be null
-   if (aResult.data) {
-     mResponse.AppendElements((uint8_t*) aResult.data, aResult.datalen);
-     QLOGD("received data length %d", aResult.datalen);
-   }
-
-     mReceivedResponse = true;
- }
-
- /**
- * Send an OEM hook request to RIL
- *
- * @param aClientId Indicate the RIL client this request is made for
- * @param aRr The OEM hook request object
- * @param aAsyncRequest Indicate if the requester expects the response to be
- * returned as synchronous or asynchronous. If synchronous is expected, the
- * following params are to be filled with the response data.
- * @param aResult The RIL_Errno result of the OEM hook request
- * @param aResponse The response data to the OEM hook request
- * @param aRespLength Length of aResponse array
- * @return The nsresult of the request
- */
-nsresult NetworkDataCollector::SendRequest(uint32_t aClientId, OemRequest* aRr,
-    bool aAsyncRequest, uint32_t* aResult, const uint8_t** aResponse,  uint32_t* aRespLength) {
-  QRLOGD("[SUB%d] [%04d]> %s", mRil->GetClientId(), aRr->mSerial,  RequestToString(aRr->mRequest));
-
-  // Only one synchronous request can be sent at a time
-  if (!aAsyncRequest) {
-    pthread_mutex_lock(&mSyncMutex);
-  }
-
-  mRil->Send(aRr);
-
-  if (aAsyncRequest) {
-    return NS_OK;
-  } else {
-    nsresult result = WaitForResponse(aResult, aResponse, aRespLength);
-    pthread_mutex_unlock(&mSyncMutex);
-    return result;
-  }
-}
-
-/**
- * Blocks the current thread until a response to an OEM hook request is
- * received or MAX_OEM_HOOK_REQ_TIME_MSEC is reached
- *
- * @param aResult The result (success/error) of the request
- * @param aResponse The response data to the OEM hook request
- * @param aRespLength Length of aResponse array
- * @return The nsresult of the request
- */
-nsresult NetworkDataCollector::WaitForResponse(uint32_t* aResult,
-    const uint8_t** aResponse, uint32_t* aRespLength) {
-    // Wait for the response to an OEM hook request until max waiting time
-    int64_t endTime = android::elapsedRealtime() + MAX_OEM_HOOK_REQ_TIME_MSEC;
-    QLOGD(" NetworkDataCollector:WaitForResponse begin loop");
-    while (android::elapsedRealtime() < endTime) {
-        if (mReceivedResponse) {
-            break;
-        }
-        usleep(SYNC_RSP_SLEEP_USEC);
-    }
-    QLOGD(" NetworkDataCollector:WaitForResponse loop finished");
-
-    // There should be a response by now
-    if (!mReceivedResponse) {
-        *aResult = RIL_E_GENERIC_FAILURE;
-        return NS_ERROR_FAILURE;
-    }
-
-    *aResult = mResult;
-    mReceivedResponse = false;
-
-    if(mResponse.Length() > 0) {
-        // Caller is responsible for freeing the response data
-        uint8_t* response = new uint8_t[mResponse.Length()];
-        memcpy(response, mResponse.Elements(), mResponse.Length());
-        *aResponse = response;
-        *aRespLength = mResponse.Length();
-    } else {
-        QLOGE(" NetworkDataCollector: data length is zero");
-        *aRespLength = 0;
-    }
-
-  return NS_OK;
-}
-
-std::string NetworkDataCollector::tohex(const  std::string& s, bool upper)
-{
-    std::ostringstream ret;
-
-    unsigned int c;
-    for (std::string::size_type i = 0; i < s.length(); ++i)
-    {
-        c = (unsigned int)(unsigned char)s[i];
-        ret << std::hex << std::setfill('0') << std::setw(2) << (upper ? std::uppercase : std::nouppercase) << c;
-    }
-    return ret.str();
-}
-
-const char* NetworkDataCollector::getDataCollectorEventCode(DataCollectorEventCodes eventType) {
-    switch(eventType) {
-        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
-            return "NE1";
-        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
-            return "NE2";
-        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
-            return "NE3";
-        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
-            return "NE4";
-        case DATA_COLLECTOR_EVENT_CALL_DROP:
-            return "NE5";
-        case DATA_COLLECTOR_EVENT_CALL_MUTING:
-            return "NE6";
-        case DATA_COLLECTOR_EVENT_SMS_SENT:
-            return "NE7";
-        case DATA_COLLECTOR_EVENT_SMS_RECIVED:
-            return "NE8";
-        case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
-            return "NE9";
-        case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
-            return "NE10";
-        case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
-            return "NE11";
-        case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
-            return "NE12";
-        case DATA_COLLECTOR_EVENT_IN_SERVICE:
-            return "NE13";
-        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
-            return "NE14";
-        case DATA_COLLECTOR_EVENT_TAC_UPDATE:
-            return "NE15";
-        case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
-            return "NE16";
-        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
-            return "NE17";
-        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
-            return "NE18";
-        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
-            return "NE19";
-        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
-            return "NE20";
-        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
-            return "NE21";
-        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
-            return "NE22";
-        case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
-            return "NE23";
-        case DATA_COLLECTOR_EVENT_RACH_FAILURE:
-            return "NE24";
-        case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
-            return "NE25";
-        case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
-            return "NE26";
-
-       default:
-        QLOGD("getDataCollectorEventCode : unexpected event code");
-            return " "; //empty string , this is not expected.
-
-    }
-}
-
-void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event) {
-    uint8_t frame[MAX_RESPONSE_BYTES];
-    bzero(frame,MAX_RESPONSE_BYTES);
-    QLOGD("NetworkDataCollector  sentNWDataToServer");
-
-    if(mSeqNumber >= 0xFFFFFFFFFFFFFFFF)
-        mSeqNumber = 1;
-
-    std::time_t currentTime = std::time(NULL);
-
-    char jsonPayload[MAX_RESPONSE_BYTES];
-    bzero(jsonPayload,MAX_RESPONSE_BYTES);
-
-    /*As per network_access_service_v01.h, QC's LTE band starts from 120.
-       Set default band as 3, if wrong band is reported. So that at least other parameters gets reported,
-       otherwise metircs server will disconnect the socket connection. This logic needs to be removed once RJIL updated their requirement*/
-    int activeband = (pNetworkParams->activeband > 119) ? (pNetworkParams->activeband-119):3;
-
-    // Note:- as per 80-nv304-6_b_qmi_network_access_service_spec , RSRP range: -44 to -140, RSRQ range : -3 to -20, LTE SNR level scaled integer in units of 0.1dB e.g. 24.6 has a value of 246.
-    sprintf (jsonPayload,"[{ \"seq_number\": %llu, \"timestamp\": %ld, \"payload\": { \"Name\":\"%s\",\"RI1\":%d,\"RI2\":%d,\"RI3\":%d,\"RI6\":%d,\"RI7\":%d,\"RI8\":%s,\"RI13\": %d,\"VI2\": %d,\"NI1\":%s,\"VI1\": \"%s\"}}]",
-                            mSeqNumber,currentTime,getDataCollectorEventCode(event),(140+pNetworkParams->rsrp),(20+pNetworkParams->rsrq),pNetworkParams->sinr/10, activeband, pNetworkParams->lte_earfcn,
-                            pNetworkParams->srv_status?"true":"false",pNetworkParams->timing_advance>0?pNetworkParams->timing_advance:0,mRilLastFailCause,pNetworkParams->Roaming_Indicator?"true":"false",(pNetworkParams->sip_reg_status==1)?"REGISTERED":"NOT REGISTER");
-
-   QLOGD(" payload = %s",jsonPayload);
-
-    mSeqNumber++;//increase it for next message
-    int length = strlen(jsonPayload);
-    QLOGD(" payload length = %d",length);
-    uint32_t nwByteOrderlength = htonl(length);
-    char numberStr[4];
-    memcpy(numberStr, &nwByteOrderlength, 4);
-
-    frame[0] = 0x01; //  this is fixed value
-    frame[1]=numberStr[0];
-    frame[2]=numberStr[1];
-    frame[3]=numberStr[2];
-    frame[4]=numberStr[3];
-
-    char stringhexdata[MAX_RESPONSE_BYTES/2];
-    std::memcpy(stringhexdata, tohex(jsonPayload).c_str(), 2*length);
-    uint8_t* body = HexStringToBytes(stringhexdata,length);
-    std::memcpy(frame+5,body,length);
-
-    if(mSocket && mSocket->mFd) {
-        int n = write(mSocket->mFd,frame,5+length); // 1 for type, 4 for length - total 5 bytes
-        if (n < 0) {
-            QRLOGE("ERROR writing to socket");
-        }
-
-    } else {
-         QRLOGE("ERROR not connected to server socket");
-    }
-
-    if(body != NULL)
-        delete [] body;
-
-}
-
-NS_IMETHODIMP NetworkDataCollector::sendHandShakeMsgToServer() {
-    uint8_t buffer[MAX_RESPONSE_BYTES];
-    QLOGD("NetworkDataCollector  sendHandShakeMsgToServer");
-    sleep(10);//Sleep for few seconds before sending data, suggested by kaios team.
-    bzero(buffer,MAX_RESPONSE_BYTES);
-    int length = strlen(INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET);
-    uint32_t nwByteOrderlength = htonl(length);
-    char numberStr[4];
-    memcpy(numberStr, &nwByteOrderlength, 4);
-    buffer[0] = 0x01; //  this is fixed value
-    buffer[1]=numberStr[0];
-    buffer[2]=numberStr[1];
-    buffer[3]=numberStr[2];
-    buffer[4]=numberStr[3];
-    std::string str1 = INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET;
-    char stringhexdata[MAX_RESPONSE_BYTES/2];
-    std::memcpy(stringhexdata, tohex(str1).c_str(), 2*length);
-    uint8_t* body = HexStringToBytes(stringhexdata,length);
-    std::memcpy(buffer+5,body,length);
-    if(mSocket && mSocket->mFd) {
-        int n = write(mSocket->mFd,buffer,5+length); // 1 for type, 4 for length -- total 5 bytes
-        if (n < 0) {
-            QRLOGE("ERROR writing to socket");
-        }
-    } else {
-        QRLOGE("ERROR no socket fd to server socket");
-    }
-
-    if(body != NULL)
-        delete [] body;
-
-    return NS_OK;
- }
-
-
-
-NS_IMETHODIMP NetworkDataCollector::Run() {
-    struct pollfd poll_rild_fd;
-    int rc = 0;
-    int ret = 0;
-    int retryCount = 0;
-    nsCString socketName;
-    nsresult result = NS_ERROR_FAILURE;
-    struct sockaddr_un serveraddr;
-    unsigned char readBuffer[MAX_RESPONSE_BYTES];
-
-    // server socket name
-    socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
-
-    QLOGD(" NetworkDataCollector:run  begin");
-    if (NS_IsMainThread()) {
-        QLOGE("Error: This will deadlock if called from the main thread");
-        return NS_ERROR_UNEXPECTED;
-    }
-
-    for (;;) {
-
-         // create the client socket and poll on it.
-        do {
-            // Always sleep first.  At boot the rild and b2g process are launched
-            // concurrently, and rild contains a race condition whereby it creates its
-            // socket before it's fully prepared to handle all the requests and network is registered.
-            sleep(NETWORK_DATA_COLLECTOR_RETRY_SECONDS);
-
-             if(mShuttingDown) {
-                QLOGE(" NetworkDataCollector: server connection is not ready or shuting down, so return");
-                return result;
-             }
-            // Connect to server socket
-            QLOGD("Connecting to socket %s", mSocket->GetName());
-            if ((mSocket->mFd = socket(AF_UNIX,SOCK_STREAM,0)) >= 0)
-           {
-                memset(&serveraddr, 0, sizeof(serveraddr));
-                serveraddr.sun_family = AF_UNIX;
-                strcpy(serveraddr.sun_path,SERVER_DATA_COLLECTOR_SOCKET_NAME);
-                QRLOGD(" NetworkDataCollector: socket fd=%d, sockaddress length= %d",mSocket->mFd,sizeof(serveraddr));
-                if( connect(mSocket->mFd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0 )
-                {
-                   QRLOGE("Connect socket failed, errno=%s",strerror(errno));
-                   // close socket so that we can create it again in loop
-                    mSocket->OnDisconnect(mRil->mIsShuttingDown);
-                } else {
-                 QRLOGD("Connect socket successful");
-                    break;
-                }
-            }
-
-            // Retry again if the socket fails to connect
-            if (retryCount == 8) {
-              QRLOGE("Couldn't connect to  '%s ' socket after %d times, "
-                      "continuing to retry silently", mSocket->GetName(), retryCount);
-            } else if (retryCount > 0 && retryCount < 8) {
-              QRLOGD("Couldn't connect to '%s' socket; retrying after timeout, errno=%s", mSocket->GetName(),strerror(errno));
-            }
-            retryCount++;
-        }while(true);
-
-       QRLOGD("Connected to socket %s", mSocket->GetName());
-       retryCount = 0;
-       if(1) {
-            // Create a thread for initial handshaking message.
-            RefPtr<nsRunnable> runnable = NS_NewRunnableMethod(this,
-                                                                  &NetworkDataCollector::sendHandShakeMsgToServer);
-            // Start the new  thread for this operation
-            NS_NewThread(getter_AddRefs(mThread), runnable);
-        }
-        // Poll the server data collector socket to see if there is data to be read
-        poll_rild_fd.fd = mSocket->mFd;
-        poll_rild_fd.events = POLLIN;
-        poll_rild_fd.revents = 0;
-
-        // Read while the socket is connected to data collector server
-        while (1) {
-            if (mShuttingDown) {
-                QRLOGW("Data collector server is shutting down; exiting NetworkDataCollector thread for socket %s",
-                         mSocket->GetName());
-                return result;
-            }
-            // Poll socket for data availability
-            rc = poll(&poll_rild_fd, 1, -1);
-
-            // If there is an error in polling
-            if (rc < 0) {
-                QRLOGE("Error in polling %s; bailing out",  mSocket->GetName());
-                break;
-            }
-
-            if (poll_rild_fd.revents == POLLERR) {
-                QRLOGE("Closing NetworkDataCollector socket %s: POLLERR", mSocket->GetName());
-                break;
-            }
-
-            // Any server data to read?
-            if (poll_rild_fd.revents != POLLIN) {
-                QRLOGD("Error! revents= %d, not POLLIN revents , rc = %d",poll_rild_fd.revents,rc);
-                break;//continue is not fiing the issue.
-            }
-
-            // Read data from the socket
-            int readResult = read(mSocket->mFd, readBuffer, MAX_RESPONSE_BYTES);
-            if((readResult < 0 )) {
-                 /* looks like socket got disconneccted at far end. */
-                 QLOGE("looks like server socket got disconneccted/closed  errno=%s",strerror(errno));
-                  break;
-             } else {
-                  // handle the data collector server response.
-                 QLOGE("got response from server socket ret=%d",readResult);
-                 mServerReady = true; // need to set on first handshake message response.
-             }
-        }
-
-        // Clean up
-        QRLOGD("Closing client socket. FD= %d", mSocket->mFd);
-        mSocket->OnDisconnect(mRil->mIsShuttingDown);
-        mServerReady = false;
-        mSeqNumber = 1;
-
-        }
-    }
-
-    void  NetworkDataCollector::HandleImsSolicitedResponse(RILResult& result) {
-        QRLOGD("HandleImsSolicitedResponse");
-        }
-    void  NetworkDataCollector::HandleImsUnSolicitedResponse(RILResult& result) {
-        QRLOGD("HandleImsUnSolicitedResponse");
-        }
-
-    void  NetworkDataCollector::SendNetworkDataToServer(DataCollectorEventCodes event) {
-    uint32_t aRespLength = 0;
-    const uint8_t **aResponse = new const uint8_t*;
-    uint32_t aResult = 0;
-    uint32_t aReqLength = 4;
-
-    QLOGD(" SendNetworkDataToServer  event = %d",event);
-
-    if(!mServerReady ||  mShuttingDown) {
-        QLOGE(" NetworkDataCollector: server connection is not ready or shuting down");
-        return;
-    }
-
-    QLOGD(" NetworkDataCollector: Extracting nework data on socket %s",  mRil->mOemSocket->GetName());
-    OemRequest* rr = OemRequest::Obtain(QRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS, this);
-    SendRequest(mRil->GetClientId(), rr, false, &aResult, aResponse, &aRespLength);
-
-    if(aRespLength > 0) {
-        qmi_ril_nw_data_collector_Params *nwParams = (qmi_ril_nw_data_collector_Params *) *aResponse;
-        //write data to server socket.
-        sendNWDataToServer(nwParams,event);
-    }
-    if((aResponse != nullptr) && (*aResponse != nullptr))
-          delete [](*aResponse);
-}
-
+/*
+ * Copyright (c) 2012-2015 Qualcomm Technologies, Inc.  All Rights Reserved.
+ * Qualcomm Technologies Proprietary and Confidential.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "NetworkDataCollector.h"
+
+/* Logging related */
+#undef LOG_TAG
+#define LOG_TAG "NW_DATA_COLLECTOR"
+#include "LogUtils.h"
+#include <utils/SystemClock.h>
+#include <iostream>
+#include <fstream>
+#include <sys/un.h>
+#include "Conversion.h"
+#include <sstream>
+#include <iomanip>
+
+
+
+
+NS_NAMED_LITERAL_CSTRING(RILD_OEM_SOCKET_NAME, "qmux_radio/rild_oem");
+
+#define NETWORK_DATA_COLLECTOR_RETRY_SECONDS 60
+// Max time to wait for a response to an OEM hook request
+#define MAX_OEM_HOOK_REQ_TIME_MSEC 10 * 1000
+
+#define NETWORK_PARAMS_LOG_FILE       "/data/data/media/network_parameters.txt"
+
+NS_NAMED_LITERAL_CSTRING(DATA_COLLECTOR_SERVER_SOCKET_NAME, "/dev/socket/metricsd_socket");
+
+#define SERVER_DATA_COLLECTOR_SOCKET_NAME  "/dev/socket/metricsd_socket"
+// Amount of time to sleep while waiting for a response to allow yielding of
+// CPU to other threads
+#define SYNC_RSP_SLEEP_USEC 50 * 1000
+
+#define MAX_COMMAND_BYTES (8 * 1024)
+
+#define MAX_RESPONSE_BYTES 1024
+
+#define INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET  "{ \"source\": \"ril_metrics\" }"
+
+#define DATA_COLLECTOR_UNSOL_OEM_HOOK_RAW_IND  525343
+
+#define LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND 525344
+
+#define QCRIL_QMI_VOICE_MAX_FAIL_CAUSE_STR_LEN     256
+
+
+typedef struct
+{
+    uint8_t frameType;
+    uint32_t payloadLength;
+    int8_t* payload;
+}data_collector_frame;
+
+/*============= Implementation of Class DataCollectorSocket =============*/
+
+/**
+ *
+ */
+DataCollectorSocket::DataCollectorSocket(NetworkDataCollector* NWDataCollector, const nsACString& name, bool useRilApi,
+    void (*dcCallback)(void*))
+    : mFd(-1),
+      mUseRilApi(useRilApi),
+      mName(name) {
+    QLOGE("NetworkDataCollector : DataCollectorSocket initialize");
+    mReceiver = NWDataCollector;
+    RefPtr<nsRunnable> runnable = NS_NewRunnableMethod(mReceiver,
+                                                                  &NetworkDataCollector::Run);
+
+    // Start the RilReceiver thread for this socket
+    NS_NewThread(getter_AddRefs(mThread), runnable);
+}
+
+/*============= Implementation of Class RilSocket =============*/
+
+/**
+ *
+ */
+DataCollectorSocket::~DataCollectorSocket() {
+  Close();
+}
+
+/**
+ * Get the name of the socket (i.e. "rild1")
+ * Returns the name as a basic C string instead of nsCString since it is always
+ * fed into functions that require a char * input.
+ */
+const char* DataCollectorSocket::GetName() {
+    return mName.get();
+};
+
+void DataCollectorSocket::Shutdown() {
+    mReceiver->Shutdown();
+}
+
+/**
+ * Closes a socket
+ */
+void DataCollectorSocket::Close() {
+    if (mFd >= 0) {
+    close(mFd);
+    }
+    mFd = -1;
+}
+
+/**
+ *
+ */
+void DataCollectorSocket::OnDisconnect(bool isShuttingDown) {
+  Close();
+//  DispatchRunnable(mDisconnectRunnable, isShuttingDown);
+}
+
+
+/*============= Implementation of Class NetworkDataCollector =============*/
+
+/**
+ *
+ */
+NetworkDataCollector::NetworkDataCollector(RIL* ril) :ImsResponseHandler(ril), mRil(ril),
+                               mSyncMutex(PTHREAD_MUTEX_INITIALIZER), mResult(RIL_E_SUCCESS), mReceivedResponse(false),mServerReady(false),mShuttingDown(false) {
+    mSeqNumber = 1; // count starts from 1
+    mSenderEvent = DATA_COLLECTOR_EVENT_CALL_TRIGGERED;
+    mRilLastFailCause = CALL_FAIL_NORMAL_UNSPECIFIED;
+    mRil->RegisterForUnsol(RIL_UNSOL_OEM_HOOK_RAW, this);
+}
+
+NetworkDataCollector::~NetworkDataCollector() {
+      mRil->UnRegisterForUnsol(RIL_UNSOL_OEM_HOOK_RAW, this);
+}
+ void NetworkDataCollector::Initialize() {
+    nsCString socketName;
+    socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
+    QLOGE("NetworkDataCollector  initialize");
+
+    mSocket = new DataCollectorSocket(this, socketName, true);
+ }
+
+ void NetworkDataCollector::Shutdown() {
+   mShuttingDown = true;
+ }
+
+ void NetworkDataCollector::HandleRilUnSolicitedResponse(RILResult& result) {
+     int messageID = result.mMessageID;
+     QLOGE("Received unsolicited response %s", RequestToString(messageID));
+
+     switch (messageID) {
+        case RIL_UNSOL_OEM_HOOK_RAW: {
+           uint8_t *p = nullptr;
+           p = (uint8_t* ) result.data;
+          QLOGE("HandleUnSolicitedResponse, data len = %d",result.datalen);
+          int index = 8; //starting index of event id and size.
+          if(result.datalen > 16) {
+             int event = (uint32_t)((p[index+3])  << 24 | (p[index+2]) << 16 | (p[index+1]) << 8 |(p[index]));
+             if(event == DATA_COLLECTOR_UNSOL_OEM_HOOK_RAW_IND) {
+                 int event_size = (uint32_t)((p[index+7])  << 24 | (p[index+6]) << 16 | (p[index+5]) << 8 |(p[index+4]));
+                 QLOGE("HandleUnSolicitedResponse, data collector event length = %d",event_size);
+                 if(event_size) {
+                     int eventType =  p[index+8];
+                     HandleDataCollectorEvent(eventType);
+                 }
+            }
+            if(event == LAST_CALL_FAIL_CAUSE_UNSOL_OEM_HOOK_RAW_IND) {
+                 int event_size = (uint32_t)((p[index+7])  << 24 | (p[index+6]) << 16 | (p[index+5]) << 8 |(p[index+4]));
+                 QLOGE("HandleUnSolicitedResponse, last fail cause event length = %d",event_size);
+                 if(event_size) {
+                     mRilLastFailCause =  (uint32_t)((p[index+11])  << 24 | (p[index+10]) << 16 | (p[index+9]) << 8 |(p[index+8]));
+                     QLOGE("HandleUnSolicitedResponse, last fail cause  = %d",mRilLastFailCause);
+                     // RJIL do not support error higher value  then CALL_FAIL_DIAL_MODIFIED_TO_DIAL(246),
+                     //because those errors are for cdma network specific and JIO network does not expect that..
+                     if(mRilLastFailCause > CALL_FAIL_DIAL_MODIFIED_TO_DIAL) {
+                        mRilLastFailCause = CALL_FAIL_NORMAL_UNSPECIFIED;
+                     }
+                }
+            }
+          }
+       }
+       break;
+       default:
+          QLOGE("%s: unexpected request %s", __FUNCTION__, RequestToString(messageID));
+       break;
+      }
+ }
+
+void  NetworkDataCollector::SendCallTriggeredDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_TRIGGERED);
+}
+
+ void  NetworkDataCollector::SendCallAttemptFailedDataToServer() {
+     QLOGE("%s new thread began", __FUNCTION__);
+     SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED);
+ }
+
+ void  NetworkDataCollector::SendCallEstablishedDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_ESTABLISHED);
+}
+
+ void  NetworkDataCollector::SendCallDisconnectDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DISCONNECT);
+}
+
+ void  NetworkDataCollector::SendCallDropDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_CALL_DROP);
+}
+
+ void  NetworkDataCollector::SendTacUpdateDataToServer() {
+    QLOGE("%s new thread began", __FUNCTION__);
+    SendNetworkDataToServer(DATA_COLLECTOR_EVENT_TAC_UPDATE);
+}
+
+
+ void NetworkDataCollector::HandleDataCollectorEvent( int eventType) {
+    bool isValidType = true;
+    RefPtr<nsRunnable> runnable = nullptr;
+    QLOGE("%s event type = %d", __FUNCTION__,eventType);
+    switch(eventType) {
+        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallTriggeredDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallAttemptFailedDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallEstablishedDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDisconnectDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_DROP:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendCallDropDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_CALL_MUTING:
+        case DATA_COLLECTOR_EVENT_SMS_SENT:
+        case DATA_COLLECTOR_EVENT_SMS_RECIVED:
+        case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
+        case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
+        case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
+        case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
+        case DATA_COLLECTOR_EVENT_IN_SERVICE:
+        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+            isValidType = false;
+            break;
+        case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+            runnable = NS_NewRunnableMethod(this, &NetworkDataCollector::SendTacUpdateDataToServer);
+            break;
+        case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
+        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+        case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+        case DATA_COLLECTOR_EVENT_RACH_FAILURE:
+        case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
+        case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
+        default:
+            isValidType = false;
+            break;
+
+        }
+
+      // Start the new  thread for this operation
+      if(isValidType)
+            NS_NewThread(getter_AddRefs(mDataCollectorSenderThread), runnable);
+    }
+
+ /**
+  * Handles the solicited requests from RIL
+  *
+  * @param aResult The response data from the OEM hook request
+  */
+ void NetworkDataCollector::HandleRilSolicitedResponse(RILResult& aResult) {
+    int messageID = aResult.mMessageID;
+    QLOGD("HandleSolicitedResponse %s", RequestToString(messageID));
+
+    if (messageID != RIL_REQUEST_OEM_HOOK_RAW) {
+       QLOGE("NetworkDataCollector Message %s not supported", RequestToString(messageID));
+       return;
+    }
+    qmi_ril_nw_data_collector_Params *nwParams = (qmi_ril_nw_data_collector_Params *)aResult.data;
+
+   mResponse.Clear();
+   mResult = aResult.mError;
+
+   // Even for success case, result data can be null
+   if (aResult.data) {
+     mResponse.AppendElements((uint8_t*) aResult.data, aResult.datalen);
+     QLOGD("received data length %d", aResult.datalen);
+   }
+
+     mReceivedResponse = true;
+ }
+
+ /**
+ * Send an OEM hook request to RIL
+ *
+ * @param aClientId Indicate the RIL client this request is made for
+ * @param aRr The OEM hook request object
+ * @param aAsyncRequest Indicate if the requester expects the response to be
+ * returned as synchronous or asynchronous. If synchronous is expected, the
+ * following params are to be filled with the response data.
+ * @param aResult The RIL_Errno result of the OEM hook request
+ * @param aResponse The response data to the OEM hook request
+ * @param aRespLength Length of aResponse array
+ * @return The nsresult of the request
+ */
+nsresult NetworkDataCollector::SendRequest(uint32_t aClientId, OemRequest* aRr,
+    bool aAsyncRequest, uint32_t* aResult, const uint8_t** aResponse,  uint32_t* aRespLength) {
+  QRLOGD("[SUB%d] [%04d]> %s", mRil->GetClientId(), aRr->mSerial,  RequestToString(aRr->mRequest));
+
+  // Only one synchronous request can be sent at a time
+  if (!aAsyncRequest) {
+    pthread_mutex_lock(&mSyncMutex);
+  }
+
+  mRil->Send(aRr);
+
+  if (aAsyncRequest) {
+    return NS_OK;
+  } else {
+    nsresult result = WaitForResponse(aResult, aResponse, aRespLength);
+    pthread_mutex_unlock(&mSyncMutex);
+    return result;
+  }
+}
+
+/**
+ * Blocks the current thread until a response to an OEM hook request is
+ * received or MAX_OEM_HOOK_REQ_TIME_MSEC is reached
+ *
+ * @param aResult The result (success/error) of the request
+ * @param aResponse The response data to the OEM hook request
+ * @param aRespLength Length of aResponse array
+ * @return The nsresult of the request
+ */
+nsresult NetworkDataCollector::WaitForResponse(uint32_t* aResult,
+    const uint8_t** aResponse, uint32_t* aRespLength) {
+    // Wait for the response to an OEM hook request until max waiting time
+    int64_t endTime = android::elapsedRealtime() + MAX_OEM_HOOK_REQ_TIME_MSEC;
+    QLOGD(" NetworkDataCollector:WaitForResponse begin loop");
+    while (android::elapsedRealtime() < endTime) {
+        if (mReceivedResponse) {
+            break;
+        }
+        usleep(SYNC_RSP_SLEEP_USEC);
+    }
+    QLOGD(" NetworkDataCollector:WaitForResponse loop finished");
+
+    // There should be a response by now
+    if (!mReceivedResponse) {
+        *aResult = RIL_E_GENERIC_FAILURE;
+        return NS_ERROR_FAILURE;
+    }
+
+    *aResult = mResult;
+    mReceivedResponse = false;
+
+    if(mResponse.Length() > 0) {
+        // Caller is responsible for freeing the response data
+        uint8_t* response = new uint8_t[mResponse.Length()];
+        memcpy(response, mResponse.Elements(), mResponse.Length());
+        *aResponse = response;
+        *aRespLength = mResponse.Length();
+    } else {
+        QLOGE(" NetworkDataCollector: data length is zero");
+        *aRespLength = 0;
+    }
+
+  return NS_OK;
+}
+
+std::string NetworkDataCollector::tohex(const  std::string& s, bool upper)
+{
+    std::ostringstream ret;
+
+    unsigned int c;
+    for (std::string::size_type i = 0; i < s.length(); ++i)
+    {
+        c = (unsigned int)(unsigned char)s[i];
+        ret << std::hex << std::setfill('0') << std::setw(2) << (upper ? std::uppercase : std::nouppercase) << c;
+    }
+    return ret.str();
+}
+
+const char* NetworkDataCollector::getDataCollectorEventCode(DataCollectorEventCodes eventType) {
+    switch(eventType) {
+        case DATA_COLLECTOR_EVENT_CALL_TRIGGERED:
+            return "NE1";
+        case DATA_COLLECTOR_EVENT_CALL_ATTEMPT_FAILED:
+            return "NE2";
+        case DATA_COLLECTOR_EVENT_CALL_ESTABLISHED:
+            return "NE3";
+        case DATA_COLLECTOR_EVENT_CALL_DISCONNECT:
+            return "NE4";
+        case DATA_COLLECTOR_EVENT_CALL_DROP:
+            return "NE5";
+        case DATA_COLLECTOR_EVENT_CALL_MUTING:
+            return "NE6";
+        case DATA_COLLECTOR_EVENT_SMS_SENT:
+            return "NE7";
+        case DATA_COLLECTOR_EVENT_SMS_RECIVED:
+            return "NE8";
+        case DATA_COLLECTOR_EVENT_VOLTE_REGISTRATION_EVENT:
+            return "NE9";
+        case DATA_COLLECTOR_EVENT_VOLTE_CONNECTION_LOST:
+            return "NE10";
+        case DATA_COLLECTOR_EVENT_AUTO_COLLECTOR_EVENT:
+            return "NE11";
+        case DATA_COLLECTOR_EVENT_OUT_OF_SERVICE:
+            return "NE12";
+        case DATA_COLLECTOR_EVENT_IN_SERVICE:
+            return "NE13";
+        case DATA_COLLECTOR_EVENT_ATTACH_FAILURE:
+            return "NE14";
+        case DATA_COLLECTOR_EVENT_TAC_UPDATE:
+            return "NE15";
+        case DATA_COLLECTOR_EVENT_RSRP_LESS_THAN_110_DBM:
+            return "NE16";
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_RELEASE:
+            return "NE17";
+        case DATA_COLLECTOR_EVENT_RRC_CONNECTION_FAILURE:
+            return "NE18";
+        case DATA_COLLECTOR_EVENT_RADIO_LINK_FAILURE:
+            return "NE19";
+        case DATA_COLLECTOR_EVENT_INTRA_FREQUENCY_HANDOVER:
+            return "NE20";
+        case DATA_COLLECTOR_EVENT_INTER_FREQUENCY_HANDOVER:
+            return "NE21";
+        case DATA_COLLECTOR_EVENT_INTER_BAND_HANDOVER:
+            return "NE22";
+        case DATA_COLLECTOR_EVENT_CELL_RESELECTION:
+            return "NE23";
+        case DATA_COLLECTOR_EVENT_RACH_FAILURE:
+            return "NE24";
+        case DATA_COLLECTOR_EVENT_DATA_PAUSE_OR_RECOVERABLE_DATA_STALL:
+            return "NE25";
+        case DATA_COLLECTOR_EVENT_NON_RECOVERABLE_DATA_STALL:
+            return "NE26";
+
+       default:
+        QLOGD("getDataCollectorEventCode : unexpected event code");
+            return " "; //empty string , this is not expected.
+
+    }
+}
+
+void NetworkDataCollector::sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event) {
+    uint8_t frame[MAX_RESPONSE_BYTES];
+    bzero(frame,MAX_RESPONSE_BYTES);
+    QLOGD("NetworkDataCollector  sentNWDataToServer");
+
+    if(mSeqNumber >= 0xFFFFFFFFFFFFFFFF)
+        mSeqNumber = 1;
+
+    std::time_t currentTime = std::time(NULL);
+
+    char jsonPayload[MAX_RESPONSE_BYTES];
+    bzero(jsonPayload,MAX_RESPONSE_BYTES);
+
+    /*As per network_access_service_v01.h, QC's LTE band starts from 120.
+       Set default band as 0 as per RJIL spec V 9.3 if the band information is not correct*/
+    int activeband = (pNetworkParams->activeband > 119) ? (pNetworkParams->activeband-119):0;
+    if(!((activeband == 3) || (activeband == 5) || (activeband == 40) ))
+        activeband = 0;
+
+    // Note:- as per 80-nv304-6_b_qmi_network_access_service_spec , RSRP range: -44 to -140, RSRQ range : -3 to -20, LTE SNR level scaled integer in units of 0.1dB e.g. 24.6 has a value of 246.
+    sprintf (jsonPayload,"[{ \"seq_number\": %llu, \"timestamp\": %ld, \"payload\": { \"Name\":\"%s\",\"RI1\":%d,\"RI2\":%d,\"RI3\":%d,\"RI6\":%d,\"RI7\":%d,\"RI8\":%s,\"RI13\": %d,\"VI2\": %d,\"NI1\":%s,\"VI1\": \"%s\"}}]",
+                            mSeqNumber,currentTime,getDataCollectorEventCode(event),(140+pNetworkParams->rsrp),(20+pNetworkParams->rsrq),pNetworkParams->sinr/10, activeband, pNetworkParams->lte_earfcn,
+                            pNetworkParams->srv_status?"true":"false",pNetworkParams->timing_advance>0?pNetworkParams->timing_advance:0,mRilLastFailCause,pNetworkParams->Roaming_Indicator?"true":"false",(pNetworkParams->sip_reg_status==1)?"REGISTERED":"NOT REGISTER");
+
+   QLOGD(" payload = %s",jsonPayload);
+
+    mSeqNumber++;//increase it for next message
+    int length = strlen(jsonPayload);
+    QLOGD(" payload length = %d",length);
+    uint32_t nwByteOrderlength = htonl(length);
+    char numberStr[4];
+    memcpy(numberStr, &nwByteOrderlength, 4);
+
+    frame[0] = 0x01; //  this is fixed value
+    frame[1]=numberStr[0];
+    frame[2]=numberStr[1];
+    frame[3]=numberStr[2];
+    frame[4]=numberStr[3];
+
+    char stringhexdata[MAX_RESPONSE_BYTES/2];
+    std::memcpy(stringhexdata, tohex(jsonPayload).c_str(), 2*length);
+    uint8_t* body = HexStringToBytes(stringhexdata,length);
+    std::memcpy(frame+5,body,length);
+
+    if(mSocket && mSocket->mFd) {
+        int n = write(mSocket->mFd,frame,5+length); // 1 for type, 4 for length - total 5 bytes
+        if (n < 0) {
+            QRLOGE("ERROR writing to socket");
+        }
+
+    } else {
+         QRLOGE("ERROR not connected to server socket");
+    }
+
+    if(body != NULL)
+        delete [] body;
+
+}
+
+NS_IMETHODIMP NetworkDataCollector::sendHandShakeMsgToServer() {
+    uint8_t buffer[MAX_RESPONSE_BYTES];
+    QLOGD("NetworkDataCollector  sendHandShakeMsgToServer");
+    sleep(10);//Sleep for few seconds before sending data, suggested by kaios team.
+    bzero(buffer,MAX_RESPONSE_BYTES);
+    int length = strlen(INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET);
+    uint32_t nwByteOrderlength = htonl(length);
+    char numberStr[4];
+    memcpy(numberStr, &nwByteOrderlength, 4);
+    buffer[0] = 0x01; //  this is fixed value
+    buffer[1]=numberStr[0];
+    buffer[2]=numberStr[1];
+    buffer[3]=numberStr[2];
+    buffer[4]=numberStr[3];
+    std::string str1 = INITIAL_HANDSHAKE_MESSAGE_WITH_SERVER_SOCKET;
+    char stringhexdata[MAX_RESPONSE_BYTES/2];
+    std::memcpy(stringhexdata, tohex(str1).c_str(), 2*length);
+    uint8_t* body = HexStringToBytes(stringhexdata,length);
+    std::memcpy(buffer+5,body,length);
+    if(mSocket && mSocket->mFd) {
+        int n = write(mSocket->mFd,buffer,5+length); // 1 for type, 4 for length -- total 5 bytes
+        if (n < 0) {
+            QRLOGE("ERROR writing to socket");
+        }
+    } else {
+        QRLOGE("ERROR no socket fd to server socket");
+    }
+
+    if(body != NULL)
+        delete [] body;
+
+    return NS_OK;
+ }
+
+
+
+NS_IMETHODIMP NetworkDataCollector::Run() {
+    struct pollfd poll_rild_fd;
+    int rc = 0;
+    int ret = 0;
+    int retryCount = 0;
+    nsCString socketName;
+    nsresult result = NS_ERROR_FAILURE;
+    struct sockaddr_un serveraddr;
+    unsigned char readBuffer[MAX_RESPONSE_BYTES];
+
+    // server socket name
+    socketName.Assign(DATA_COLLECTOR_SERVER_SOCKET_NAME);
+
+    QLOGD(" NetworkDataCollector:run  begin");
+    if (NS_IsMainThread()) {
+        QLOGE("Error: This will deadlock if called from the main thread");
+        return NS_ERROR_UNEXPECTED;
+    }
+
+    for (;;) {
+
+         // create the client socket and poll on it.
+        do {
+            // Always sleep first.  At boot the rild and b2g process are launched
+            // concurrently, and rild contains a race condition whereby it creates its
+            // socket before it's fully prepared to handle all the requests and network is registered.
+            sleep(NETWORK_DATA_COLLECTOR_RETRY_SECONDS);
+
+             if(mShuttingDown) {
+                QLOGE(" NetworkDataCollector: server connection is not ready or shuting down, so return");
+                return result;
+             }
+            // Connect to server socket
+            QLOGD("Connecting to socket %s", mSocket->GetName());
+            if ((mSocket->mFd = socket(AF_UNIX,SOCK_STREAM,0)) >= 0)
+           {
+                memset(&serveraddr, 0, sizeof(serveraddr));
+                serveraddr.sun_family = AF_UNIX;
+                strcpy(serveraddr.sun_path,SERVER_DATA_COLLECTOR_SOCKET_NAME);
+                QRLOGD(" NetworkDataCollector: socket fd=%d, sockaddress length= %d",mSocket->mFd,sizeof(serveraddr));
+                if( connect(mSocket->mFd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0 )
+                {
+                   QRLOGE("Connect socket failed, errno=%s",strerror(errno));
+                   // close socket so that we can create it again in loop
+                    mSocket->OnDisconnect(mRil->mIsShuttingDown);
+                } else {
+                 QRLOGD("Connect socket successful");
+                    break;
+                }
+            }
+
+            // Retry again if the socket fails to connect
+            if (retryCount == 8) {
+              QRLOGE("Couldn't connect to  '%s ' socket after %d times, "
+                      "continuing to retry silently", mSocket->GetName(), retryCount);
+            } else if (retryCount > 0 && retryCount < 8) {
+              QRLOGD("Couldn't connect to '%s' socket; retrying after timeout, errno=%s", mSocket->GetName(),strerror(errno));
+            }
+            retryCount++;
+        }while(true);
+
+       QRLOGD("Connected to socket %s", mSocket->GetName());
+       retryCount = 0;
+       if(1) {
+            // Create a thread for initial handshaking message.
+            RefPtr<nsRunnable> runnable = NS_NewRunnableMethod(this,
+                                                                  &NetworkDataCollector::sendHandShakeMsgToServer);
+            // Start the new  thread for this operation
+            NS_NewThread(getter_AddRefs(mThread), runnable);
+        }
+        // Poll the server data collector socket to see if there is data to be read
+        poll_rild_fd.fd = mSocket->mFd;
+        poll_rild_fd.events = POLLIN;
+        poll_rild_fd.revents = 0;
+
+        // Read while the socket is connected to data collector server
+        while (1) {
+            if (mShuttingDown) {
+                QRLOGW("Data collector server is shutting down; exiting NetworkDataCollector thread for socket %s",
+                         mSocket->GetName());
+                return result;
+            }
+            // Poll socket for data availability
+            rc = poll(&poll_rild_fd, 1, -1);
+
+            // If there is an error in polling
+            if (rc < 0) {
+                QRLOGE("Error in polling %s; bailing out",  mSocket->GetName());
+                break;
+            }
+
+            if (poll_rild_fd.revents == POLLERR) {
+                QRLOGE("Closing NetworkDataCollector socket %s: POLLERR", mSocket->GetName());
+                break;
+            }
+
+            // Any server data to read?
+            if (poll_rild_fd.revents != POLLIN) {
+                QRLOGD("Error! revents= %d, not POLLIN revents , rc = %d",poll_rild_fd.revents,rc);
+                break;//continue is not fiing the issue.
+            }
+
+            // Read data from the socket
+            int readResult = read(mSocket->mFd, readBuffer, MAX_RESPONSE_BYTES);
+            if((readResult < 0 )) {
+                 /* looks like socket got disconneccted at far end. */
+                 QLOGE("looks like server socket got disconneccted/closed  errno=%s",strerror(errno));
+                  break;
+             } else {
+                  // handle the data collector server response.
+                 QLOGE("got response from server socket ret=%d",readResult);
+                 mServerReady = true; // need to set on first handshake message response.
+             }
+        }
+
+        // Clean up
+        QRLOGD("Closing client socket. FD= %d", mSocket->mFd);
+        mSocket->OnDisconnect(mRil->mIsShuttingDown);
+        mServerReady = false;
+        mSeqNumber = 1;
+
+        }
+    }
+
+    void  NetworkDataCollector::HandleImsSolicitedResponse(RILResult& result) {
+        QRLOGD("HandleImsSolicitedResponse");
+        }
+    void  NetworkDataCollector::HandleImsUnSolicitedResponse(RILResult& result) {
+        QRLOGD("HandleImsUnSolicitedResponse");
+        }
+
+    void  NetworkDataCollector::SendNetworkDataToServer(DataCollectorEventCodes event) {
+    uint32_t aRespLength = 0;
+    const uint8_t **aResponse = new const uint8_t*;
+    uint32_t aResult = 0;
+    uint32_t aReqLength = 4;
+
+    QLOGD(" SendNetworkDataToServer  event = %d",event);
+
+    if(!mServerReady ||  mShuttingDown) {
+        QLOGE(" NetworkDataCollector: server connection is not ready or shuting down");
+        return;
+    }
+
+    QLOGD(" NetworkDataCollector: Extracting nework data on socket %s",  mRil->mOemSocket->GetName());
+    OemRequest* rr = OemRequest::Obtain(QRIL_EVT_HOOK_NAS_GET_NW_DATA_COLLECTOR_PARAMS, this);
+    SendRequest(mRil->GetClientId(), rr, false, &aResult, aResponse, &aRespLength);
+
+    if(aRespLength > 0) {
+        qmi_ril_nw_data_collector_Params *nwParams = (qmi_ril_nw_data_collector_Params *) *aResponse;
+        //write data to server socket.
+        sendNWDataToServer(nwParams,event);
+    }
+    if((aResponse != nullptr) && (*aResponse != nullptr))
+          delete [](*aResponse);
+}
+
diff --git a/b2g_telephony/include/NetworkDataCollector.h b/b2g_telephony/include/NetworkDataCollector.h
old mode 100644
new mode 100755
index 0a5a72c..3479953
--- a/b2g_telephony/include/NetworkDataCollector.h
+++ b/b2g_telephony/include/NetworkDataCollector.h
@@ -1,124 +1,124 @@
-/*
- * Copyright (c) 2012-2013,2017 Qualcomm Technologies, Inc.
- * All Rights Reserved.
- * Confidential and Proprietary - Qualcomm Technologies, Inc
- *
- * Not a Contribution, Apache license notifications and license are retained
- * for attribution purposes only.
- */
-
-/*
- * Copyright (C) 2006 The Android Open Source Project
- * Copyright (c) 2012 Code Aurora Forum. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef NETWORK_DATA_COLLECTOR_H
-#define NETWORK_DATA_COLLECTOR_H
-
-#include "RIL.h"
-
-class RIL;
-class RILResult;
-class RilSocket;
-class OemRequest;
-class RilResponseHandler;
-
-
-typedef struct
-{
-    int32_t rsrp;
-    int32_t rsrq;
-    int32_t sinr;
-    int32_t activeband;
-    uint32_t lte_earfcn;
-    int32_t  srv_status;
-    int32_t timing_advance;
-    int32_t Roaming_Indicator;
-    int32_t sip_reg_status;
-    int32_t tac;
-}qmi_ril_nw_data_collector_Params;
-
-class DataCollectorSocket {
-public:
-  DataCollectorSocket(NetworkDataCollector* ril, const nsACString& name, bool useRilApi,
-      void (*dcCallback)(void*) = nullptr);
-  ~DataCollectorSocket();
-  const char* GetName();
-  void Close();
-  void Shutdown();
-  void OnDisconnect(bool isShuttingDown);
-  int mFd;
-  bool mUseRilApi;
-
-private:
-  nsCString mName;
-  RefPtr<NetworkDataCollector> mReceiver;
-  nsCOMPtr<nsIThread> mThread;
-};
-
-/**
- * This class provides method to send RIL messages to
- * oem socket on a {@code mDataCollectorThread thread}
- */
-class NetworkDataCollector : public nsRunnable, public ImsResponseHandler {
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(NetworkDataCollector);
-  NetworkDataCollector(RIL* ril);
-  void Initialize();
-  NS_IMETHOD Run();
-  NS_IMETHODIMP sendHandShakeMsgToServer();
-  void HandleRilSolicitedResponse(RILResult& result);
-  void HandleRilUnSolicitedResponse(RILResult& result);
-  void HandleImsSolicitedResponse(RILResult& result);
-  void HandleImsUnSolicitedResponse(RILResult& result);
-  void  SendNetworkDataToServer(DataCollectorEventCodes event);
-  void  SendCallTriggeredDataToServer();
-  void  SendCallAttemptFailedDataToServer();
-  void  SendCallEstablishedDataToServer();
-  void  SendCallDisconnectDataToServer();
-  void  SendCallDropDataToServer();
-  void  SendTacUpdateDataToServer();
-  void HandleDataCollectorEvent( int eventType);
-  void Shutdown();
-  std::string tohex(const  std::string& s, bool upper=true);
-  friend class RilResponseHandler;
-  friend class RIL;
-
-private:
-  ~NetworkDataCollector();
-  nsresult SendRequest(uint32_t aClientId, OemRequest* aRr,  bool aAsyncRequest, uint32_t* aResult, const uint8_t** aResponse,  uint32_t* aRespLength);
-  nsresult WaitForResponse(uint32_t* aResult,  const uint8_t** aResponse, uint32_t* aRespLength);
-  void sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event);
-  const char* getDataCollectorEventCode(DataCollectorEventCodes eventType);
-  RIL* mRil;
-  DataCollectorSocket* mSocket;
-    // Used to simulate synchronous calls
-  pthread_mutex_t mSyncMutex;
-  uint32_t mResult;
-  bool mReceivedResponse;
-  nsTArray<uint8_t> mResponse;
-  RefPtr<NetworkDataCollector> mNetworkDataCollector;
-  nsCOMPtr<nsIThread> mDataCollectorThread;
-  bool mServerReady;
-  bool mShuttingDown;
-  nsCOMPtr<nsIThread> mThread;
-  nsCOMPtr<nsIThread> mDataCollectorSenderThread;
-  uint64_t mSeqNumber;
-  DataCollectorEventCodes mSenderEvent;
-  uint32_t mRilLastFailCause;
-};
-
-#endif // NETWORK_DATA_COLLECTOR_H
-
+/*
+ * Copyright (c) 2012-2013,2017 Qualcomm Technologies, Inc.
+ * All Rights Reserved.
+ * Confidential and Proprietary - Qualcomm Technologies, Inc
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2012 Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NETWORK_DATA_COLLECTOR_H
+#define NETWORK_DATA_COLLECTOR_H
+
+#include "RIL.h"
+
+class RIL;
+class RILResult;
+class RilSocket;
+class OemRequest;
+class RilResponseHandler;
+
+
+typedef struct
+{
+    int32_t rsrp;
+    int32_t rsrq;
+    int32_t sinr;
+    int32_t activeband;
+    uint32_t lte_earfcn;
+    int32_t  srv_status;
+    int32_t timing_advance;
+    int32_t Roaming_Indicator;
+    int32_t sip_reg_status;
+    int32_t tac;
+}qmi_ril_nw_data_collector_Params;
+
+class DataCollectorSocket {
+public:
+  DataCollectorSocket(NetworkDataCollector* ril, const nsACString& name, bool useRilApi,
+      void (*dcCallback)(void*) = nullptr);
+  ~DataCollectorSocket();
+  const char* GetName();
+  void Close();
+  void Shutdown();
+  void OnDisconnect(bool isShuttingDown);
+  int mFd;
+  bool mUseRilApi;
+
+private:
+  nsCString mName;
+  RefPtr<NetworkDataCollector> mReceiver;
+  nsCOMPtr<nsIThread> mThread;
+};
+
+/**
+ * This class provides method to send RIL messages to
+ * oem socket on a {@code mDataCollectorThread thread}
+ */
+class NetworkDataCollector : public nsRunnable, public ImsResponseHandler {
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(NetworkDataCollector);
+  NetworkDataCollector(RIL* ril);
+  void Initialize();
+  NS_IMETHOD Run();
+  NS_IMETHODIMP sendHandShakeMsgToServer();
+  void HandleRilSolicitedResponse(RILResult& result);
+  void HandleRilUnSolicitedResponse(RILResult& result);
+  void HandleImsSolicitedResponse(RILResult& result);
+  void HandleImsUnSolicitedResponse(RILResult& result);
+  void  SendNetworkDataToServer(DataCollectorEventCodes event);
+  void  SendCallTriggeredDataToServer();
+  void  SendCallAttemptFailedDataToServer();
+  void  SendCallEstablishedDataToServer();
+  void  SendCallDisconnectDataToServer();
+  void  SendCallDropDataToServer();
+  void  SendTacUpdateDataToServer();
+  void HandleDataCollectorEvent( int eventType);
+  void Shutdown();
+  std::string tohex(const  std::string& s, bool upper=true);
+  friend class RilResponseHandler;
+  friend class RIL;
+
+private:
+  ~NetworkDataCollector();
+  nsresult SendRequest(uint32_t aClientId, OemRequest* aRr,  bool aAsyncRequest, uint32_t* aResult, const uint8_t** aResponse,  uint32_t* aRespLength);
+  nsresult WaitForResponse(uint32_t* aResult,  const uint8_t** aResponse, uint32_t* aRespLength);
+  void sendNWDataToServer(qmi_ril_nw_data_collector_Params *pNetworkParams,DataCollectorEventCodes event);
+  const char* getDataCollectorEventCode(DataCollectorEventCodes eventType);
+  RIL* mRil;
+  DataCollectorSocket* mSocket;
+    // Used to simulate synchronous calls
+  pthread_mutex_t mSyncMutex;
+  uint32_t mResult;
+  bool mReceivedResponse;
+  nsTArray<uint8_t> mResponse;
+  RefPtr<NetworkDataCollector> mNetworkDataCollector;
+  nsCOMPtr<nsIThread> mDataCollectorThread;
+  bool mServerReady;
+  bool mShuttingDown;
+  nsCOMPtr<nsIThread> mThread;
+  nsCOMPtr<nsIThread> mDataCollectorSenderThread;
+  uint64_t mSeqNumber;
+  DataCollectorEventCodes mSenderEvent;
+  uint32_t mRilLastFailCause;
+};
+
+#endif // NETWORK_DATA_COLLECTOR_H
+
-- 
1.9.1

