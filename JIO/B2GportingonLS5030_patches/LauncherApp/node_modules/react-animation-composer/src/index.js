import React from 'react';
import ReactDOM from 'react-dom';
import BaseComponent from 'base-component';
import ShadowWindow from './shadow_window';
import '../scss/index.scss';

export default class XWindow extends BaseComponent {
  static defaultProps = {
    openAnimation: 'immediate',
    closeAnimation: 'immediate',
    noFocus: false
  };
  static propTypes = {
    openAnimation: React.PropTypes.string,
    closeAnimation: React.PropTypes.string,
    noFocus: React.PropTypes.bool
  };

  isHidden() {
    return this.state.transition !== 'opened';
  }

  constructor(props) {
    super(props);
    this.state = {
      transition: 'closed',
      animation: 'immediate'
    };
  }

  isActive() {
    return (
      'opened' === this.state.transition ||
      'opening' === this.state.transition
    );
  }

  isTransitioning() {
    return (
      'opening' === this.state.transition ||
      'closing' === this.state.transition
    );
  }

  onAnimationEnd(e) {
    if (e.target !== ReactDOM.findDOMNode(this)) {
      return;
    }
    switch (this.state.transition) {
      case 'opening':
        this.setState({ transition: 'opened', animation: '' });
        break;
      case 'closing':
        this.setState({ transition: 'closed', animation: '' });
        break;
      default:
        break;
    }
  }

  componentDidMount() {
    ReactDOM.findDOMNode(this).addEventListener('animationend', this.onAnimationEnd.bind(this), false);
  }

  getActivatedState() {
    switch (this.state.transition) {
      case 'opening':
        return '-activating';
      case 'closing':
        return '-deactivating';
      case 'opened':
        return '-activated';
      case 'closed':
        return '-deactivated';
      default:
        break;
    }
  }

  componentDidUpdate() {
    this.emit(this.state.transition);
    this.publish(this.getActivatedState()); // For hierarchy management
    let xWindow = React.Children.toArray(this.props.children)[0];
    let xDocument = ReactDOM.findDOMNode(this.refs.shadow).firstChild;
    if (!xDocument) {
      this.debug('no content');
      return;
    }
    if ('opened' === this.state.transition) {
      this.debug('focusing inner content');
      if (this.props.noFocus) {
        return;
      }
      // XXX: This is a hack; we expect SimpleNavigationHelper to update this for us.
      if (xDocument.activeElement) {
        xDocument.activeElement.focus();
      } else {
        xDocument.focus();
      }
    } else if ('closing' === this.state.transition) {
      xDocument.blur();
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return (nextState.transition !== this.state.transition) ||
           (nextState.animation !== this.state.animation);
  }

  /**
   * Public open method. This will be used by the WindowManager.
   * @param  {String} [animation] The className of the open animation.
   */
  open(animation) {
    animation = animation || this.props.openAnimation;
    switch (this.state.transition) {
      case 'opened':
        break;
      case 'opening':
      case 'closing':
      case 'closed':
        if ('immediate' === animation || !animation) {
          this.setState({transition: 'opened', animation: ''});
        } else {
          this.setState({transition: 'opening', animation: animation});
        }
        break;
      default:
        break;
    }
  }

  focus() {
    var xDocument = ReactDOM.findDOMNode(this.refs.shadow).firstChild;
    xDocument && xDocument.focus();
  }

  /**
   * Public close method. This will be used by the WindowManager.
   * @param  {String} [animation] The className of the close animation.
   */
  close(animation) {
    animation = animation || this.props.closeAnimation;
    switch (this.state.transition) {
      case 'closed':
        break;
      case 'opening':
      case 'closing':
      case 'opened':
        if ('immediate' === animation || !animation) {
          this.setState({ transition: 'closed', animation: '' });
        } else {
          this.setState({ transition: 'closing', animation: animation });
        }
        break;
      default:
        break;
    }
  }

  render() {
    // We are setting aria-hidden to all windows except it is opened.
    // So NavigationHeleper can know it should focus or not during the transition.
    return (
      <div
        tabIndex="-1"
        className={"x-window " + this.state.animation}
        aria-hidden={this.state.transition === 'opened' ? 'false' : 'true'}
        data-transition-state={this.state.transition}
      >
        <ShadowWindow ref='shadow' transition={this.state.transition} animation={this.state.animation}>{this.props.children}</ShadowWindow>
      </div>
    );
  }
};
