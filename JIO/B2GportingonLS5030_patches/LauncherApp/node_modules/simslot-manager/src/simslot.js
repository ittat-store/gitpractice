import BaseModule from 'base-module';

export default class SIMSlot extends BaseModule {
  /**
   * The prefix of every event published by the SIMSlot instance.
   * @type {String}
   */
  EVENT_PREFIX = 'simslot-';

  /**
   * SIMSlot is the API wrapper for each mobileConnection,
   * and since one mobileConnection matches one SIM slot,
   * we call it SIMSlot.
   *
   * @param {Object} conn  mobileConnection
   * @param {index} index The slot number of this SIM slot.
   * @param {Object} [card] iccObject
   *
   * @property {Object} simCard Represent the current active iccObj,
   *                         i.e., SIM card.
   * @property {Number} index The slot number of this SIM slot.
   */
  constructor(conn, index, card) {
    super();
    this.index = index;
    this.conn = conn;
    if (card) {
      this.update(card);
    }

    /**
     * TODO: Add event listeners on this.conn
     */
    /**
     * The event represents the instance is initialized.
     * @event SIMSlot#simslot-created
     */
    this.publish('created');
  };

  EVENTS = ['cardstatechange', 'iccinfochange', 'stkcommand', 'stksessionend'];

  METHODS = ['sendStkResponse', 'sendStkMenuSelection',
             'sendStkTimerExpiration', 'sendStkEventDownload'];

  DOM_REQUEST_METHODS = ['getCardLock', 'unlockCardLock', 'setCardLock',
                       'getCardLockRetryCount', 'readContacts',
                       'updateContact', 'iccOpenChannel', 'iccExchangeAPDU',
                       'iccCloseChannel'];

  LOCK_TYPES = ['pinRequired', 'pukRequired', 'networkLocked',
                'corporateLocked', 'serviceProviderLocked',
                'network1Locked', 'network2Locked', 'hrpdNetworkLocked',
                'ruimCorporateLocked', 'ruimServiceProviderLocked',
                'permanentBlocked'];

  /**
   * Update the iccObj.
   *
   * This method is called by SIMSlotManager when the iccObj
   * needs to be updated.
   * @param  {Object} iccObj The iccObj belongs to this slot.
   */
  update(iccObj) {
    this.simCard = iccObj;
    this.EVENTS.forEach(function iterater(evt) {
      iccObj.addEventListener(evt, this);
    }, this);

    this.DOM_REQUEST_METHODS.forEach(function iterator(domRequest) {
      this[domRequest] = function() {
        return iccObj[domRequest].apply(iccObj, arguments);
      };
    }, this);

    this.METHODS.forEach(function iterator(method) {
      this[method] = function() {
        return iccObj[method].apply(iccObj, arguments);
      };
    }, this);

    this.publish('updated');
  }

  handleEvent(evt) {
    switch (evt.type) {
      default:
        this.publish(evt.type);
        if (this.simCard) {
          this.debug(this.simCard.cardState);
        }
        break;
    }
  }

  /**
   * Indicate the slot has SIM card or not.
   * @return {Boolean} Without SIM card or not.
   */
  isAbsent() {
    return (!this.simCard ||
      this.simCard && this.simCard.iccInfo &&
      this.simCard.iccInfo.iccid === null);
  }

  /**
   * Function to get simcard's smsc number
   * @param {Function} cb your callback function to get smsc number
   */
  getSmsc(cb) {
    var mobileMessage = window.navigator.mozMobileMessage;
    if (!mobileMessage) {
      console.error('can\'t access mozMobileMessage');
      cb(null);
    } else {
      var req = mobileMessage.getSmscAddress(this.index);
      req.onsuccess = function() {
        var smsc = this.result.split(',')[0].replace(/"/g, '');
        cb(smsc);
      };

      req.onerror = function() {
        console.error(this.error);
        cb(null);
      };
    }
  }

  isUnknownState() {
    var empty = (this.simCard.cardState === '');
    var unknown = (this.simCard.cardState === 'unknown');
    return !this.simCard.cardState || unknown || empty;
  }

  /**
   * Indicate SIM card in the slot is locked or not.
   * @return {Boolean} SIM card locked or not.
   */
  isLocked() {
    return this.simCard && this.LOCK_TYPES.indexOf(this.simCard.cardState) >= 0;
  }

  getCardState() {
    return this.simCard.cardState;
  }
}
