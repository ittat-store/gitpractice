import BaseEmitter from 'base-emitter';
class SoftKeyStore extends BaseEmitter {
  name = 'SoftKeyStore';
  start() {
    this.currentKeys = {};
    this.currentTheme = null;
    this.registeredDOMMap = new Map();
  }
  register(keys, dom, theme) {
    var currentInstance = this.registeredDOMMap.get(dom);
    var self = this;
    if (!currentInstance) {
      currentInstance = {
        start: function() {
          dom.addEventListener('focus', this, true);
          this.theme = theme;
          this.updateKeys(keys);
        },
        stop: function() {
          dom.removeEventListener('focus', this, true);
        },
        handleEvent: function() {
          this.check();
        },
        check: function() {
          if (document.activeElement === dom || dom.contains(document.activeElement)) {   
            var result = self.recount();
            self.store(result, this.theme);
          }
        },
        updateKeys: function(keys) {
          this.keys = keys;
          this.check();
        }
      };
      this.registeredDOMMap.set(dom, currentInstance);
      currentInstance.start();
    } else {
      currentInstance.updateKeys(keys);
    }
  }

  generateKeysInfo(keys) {
    var keysInfo = [];
    for (var key in keys) {
      var info = {};
      switch(key) {
        case 'left':
          info.code = 'SoftLeft';
          break;
        case 'center':
          info.code = 'Enter';
          break;
        case 'right':
          info.code = 'SoftRight';
          break;
      }
      info.options = {
        'name': keys[key]
      };
      keysInfo.push(info);
    }
    return keysInfo;
  }

  registerSoftkeys(keys) {
    var keysInfo = this.generateKeysInfo(keys);
    
    if (!keysInfo.length) {
      return;
    }

    // registerKeys via softkeyManager
    if(navigator.softkeyManager) {
      keysInfo.forEach((key) => {
        if (key.options.name) {
          let id = '';
          if (typeof key.options.name === 'object') {
            id = key.options.name.text || id;
          } else {
            id = key.options.name;
          }
          key.options.name = this.toL10n(id);
        }
      });
      navigator.softkeyManager.registerKeys(keysInfo);
    }
  }

  toL10n(id = '') {
    if ('complete' !== navigator.mozL10n.readyState || !id) {
      return id;
    }
    return navigator.mozL10n.get(id) || id;
  }

  store(keys, theme) {
    this.currentKeys = keys;
    this.currentTheme = theme;
    this.registerSoftkeys(keys);
    this.emit('change');
  }

  recount() {
    var result = {};
    var current = document.activeElement;
    while (current !== document.body) {
      var instance = this.registeredDOMMap.get(current);
      if (instance) {
        var keys = instance.keys;
        for (var key in keys) {
          if (!(key in result)) {
            result[key] = keys[key];
          }
        }
      }
      current = current.parentNode;
    }
    return result;
  }

  unregister(dom) {
    this.currentKeys = {};
    var instance = this.registeredDOMMap.get(dom);
    if (!instance) {
      return;
    }
    instance.stop();
    this.registeredDOMMap.delete(dom);
    this.store(this.recount());
  }
};

var softKeyStoreInstance = new SoftKeyStore();
softKeyStoreInstance.start();

export default softKeyStoreInstance;
